
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="404Forest">
    <title>ES6重点概览 - 404Forest</title>
    <meta name="author" content="Jin">
    
        <link rel="icon" href="/assets/images/favicon.ico">
    
    
    <meta name="description" content="本文是阮一峰书籍《ECMAScript 6 入门》的读书笔记，并进行了精简和整合，用20%的篇幅覆盖80%的功能，可以用来速查ES6知识。">
<meta property="og:type" content="blog">
<meta property="og:title" content="ES6重点概览">
<meta property="og:url" content="http://www.404forest.com/2016/03/13/ES6%E9%87%8D%E7%82%B9%E6%A6%82%E8%A7%88/index.html">
<meta property="og:site_name" content="404Forest">
<meta property="og:description" content="本文是阮一峰书籍《ECMAScript 6 入门》的读书笔记，并进行了精简和整合，用20%的篇幅覆盖80%的功能，可以用来速查ES6知识。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2016-03-14T01:25:11.000Z">
<meta property="article:modified_time" content="2025-02-04T23:02:44.254Z">
<meta property="article:author" content="Jin">
<meta property="article:tag" content="javascript">
<meta property="article:tag" content="ES6">
<meta name="twitter:card" content="summary">
<meta name="twitter:creator" content="@jin5354">
    
    
    
        <meta property="og:image" content="/assets/images/ava.png"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style.min.css">

    <!--STYLES END-->
    
    <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-66492678-1']);
        _gaq.push(['_trackPageview']);
        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
    </script>

</head>

    <body>
        <div id="blog">
            <header id="header" data-behavior="3">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <h1 class="header-title">
        <a class="header-title-link" href="/%20">404Forest</a>
    </h1>
    
        <a class="header-right-picture" href="/#about">
            <img class="header-picture" src="/assets/images/ava.png"/>
        </a>
    
</header>
            <nav id="sidebar" data-behavior="3">
    
        <div class="sidebar-profile">
            <a href="/#about">
                
                    <img class="sidebar-profile-picture" src="/assets/images/ava.png"/>
                
            </a>
            <span class="sidebar-profile-name">Jin</span>
        </div>
    
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/%20"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                    <span class="sidebar-button-desc">Home</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-archives"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                    <span class="sidebar-button-desc">Archive</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-categories"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
                    <span class="sidebar-button-desc">Categories</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-tags"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                    <span class="sidebar-button-desc">Tags</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link st-search-show-outputs"
                         href="#search"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-search"></i>
                    <span class="sidebar-button-desc">Search</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="#about"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-question"></i>
                    <span class="sidebar-button-desc">About</span>
                </a>
        </li>
        
    </ul>
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://github.com/jin5354" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-github"></i>
                    <span class="sidebar-button-desc">GitHub</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="mailto:xiaoyanjinx@gmail.com" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-envelope-o"></i>
                    <span class="sidebar-button-desc">Mail</span>
                </a>
        </li>
        
    </ul>
    
    <div style="margin-left: 27px;">
        <a target="_blank" rel="noopener" href="https://github.com/jin5354/404forest"><img src="https://img.shields.io/github/stars/jin5354/404forest.svg?style=social&label=Stars"></a>
    </div>
</nav>

            
            <div id="main" data-behavior="3"
                 class="
                        hasCoverMetaIn
                        ">
                <article class="post" itemscope itemType="http://schema.org/BlogPosting">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title" itemprop="headline">
            ES6重点概览
        </h1>
    
    <div class="post-meta">
    <time itemprop="datePublished" content="Sun Mar 13 2016 18:25:11 GMT-0700">
	
		    3月 13, 2016
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Code/">Code</a>


    
</div>
</div>
    
    <div class="main-content-wrap" style="margin-top: 60px;">索引</div>
    <ol class="main-content-wrap toc-article"><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-1"><a class="main-content-wrap toc-article-link" href="#let-%E4%B8%8E-const"><span class="main-content-wrap toc-article-text">let 与 const</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-1"><a class="main-content-wrap toc-article-link" href="#%E5%8F%98%E9%87%8F%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="main-content-wrap toc-article-text">变量解构赋值</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-1"><a class="main-content-wrap toc-article-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%A9%E5%B1%95"><span class="main-content-wrap toc-article-text">字符串扩展</span></a><ol class="main-content-wrap toc-article-child"><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#%E5%AD%97%E7%AC%A6%E7%9A%84Unicode%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="main-content-wrap toc-article-text">字符的Unicode表示法</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#codePointAt-%E8%BF%94%E5%9B%9E%E5%AD%97%E7%AC%A6%E7%A0%81%E7%82%B9"><span class="main-content-wrap toc-article-text">codePointAt() 返回字符码点</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#String-fromCodePoint-%E4%BB%8E%E7%A0%81%E7%82%B9%E8%BF%94%E5%9B%9E%E5%AD%97%E7%AC%A6"><span class="main-content-wrap toc-article-text">String.fromCodePoint() 从码点返回字符</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%81%8D%E5%8E%86%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="main-content-wrap toc-article-text">字符串的遍历器接口</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#at-%E8%BF%94%E5%9B%9E%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E5%AD%97%E7%AC%A6"><span class="main-content-wrap toc-article-text">at() 返回指定位置字符</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#normalize-%E7%BB%9F%E4%B8%80%E5%AD%97%E7%AC%A6"><span class="main-content-wrap toc-article-text">normalize() 统一字符</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#includes-startsWith-endsWith-%E7%A1%AE%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E5%9C%A8%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD"><span class="main-content-wrap toc-article-text">includes(), startsWith(), endsWith() 确定一个字符串是否包含在另一个字符串中</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#repeat-%E9%87%8D%E5%A4%8D%E5%8E%9F%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="main-content-wrap toc-article-text">repeat() 重复原字符串</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#padStart-%EF%BC%8CpadEnd-%E9%80%9A%E8%BF%87%E6%8C%87%E5%AE%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A5%E5%85%A8%E5%8E%9F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%B0%E6%8C%87%E5%AE%9A%E9%95%BF%E5%BA%A6"><span class="main-content-wrap toc-article-text">padStart()，padEnd() 通过指定字符串补全原字符串到指定长度</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#String-raw-%E8%BF%94%E5%9B%9E%E6%96%9C%E6%9D%A0%E8%A2%AB%E8%BD%AC%E4%B9%89%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="main-content-wrap toc-article-text">String.raw() 返回斜杠被转义的字符串</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="main-content-wrap toc-article-text">模板字符串</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#%E6%A0%87%E7%AD%BE%E6%A8%A1%E6%9D%BF"><span class="main-content-wrap toc-article-text">标签模板</span></a></li></ol></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-1"><a class="main-content-wrap toc-article-link" href="#%E6%AD%A3%E5%88%99%E6%89%A9%E5%B1%95"><span class="main-content-wrap toc-article-text">正则扩展</span></a><ol class="main-content-wrap toc-article-child"><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#RegExp%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="main-content-wrap toc-article-text">RegExp构造函数</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#u%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="main-content-wrap toc-article-text">u修饰符</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#y%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="main-content-wrap toc-article-text">y修饰符</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#flags%E5%B1%9E%E6%80%A7"><span class="main-content-wrap toc-article-text">flags属性</span></a></li></ol></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-1"><a class="main-content-wrap toc-article-link" href="#%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95"><span class="main-content-wrap toc-article-text">数值的扩展</span></a><ol class="main-content-wrap toc-article-child"><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%85%AB%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="main-content-wrap toc-article-text">二进制和八进制表示法</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#Number-isFinite-Number-isNaN-%E6%A3%80%E6%9F%A5Infinite%E4%B8%8ENaN"><span class="main-content-wrap toc-article-text">Number.isFinite(), Number.isNaN() 检查Infinite与NaN</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#Number-parseInt-Number-parseFloat"><span class="main-content-wrap toc-article-text">Number.parseInt(), Number.parseFloat()</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#Number-isInteger-%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%80%BC%E6%98%AF%E5%90%A6%E4%B8%BA%E6%95%B4%E6%95%B0"><span class="main-content-wrap toc-article-text">Number.isInteger() 判断一个值是否为整数</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#Number-EPSILON-%E6%9E%81%E5%B0%8F%E5%B8%B8%E9%87%8F%EF%BC%8C%E7%94%A8%E4%BA%8E%E5%88%A4%E6%96%AD%E8%AF%AF%E5%B7%AE"><span class="main-content-wrap toc-article-text">Number.EPSILON 极小常量，用于判断误差</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#%E5%AE%89%E5%85%A8%E6%95%B4%E6%95%B0%E5%92%8CNumber-isSafeInteger-%E6%A3%80%E6%9F%A5%E5%AE%89%E5%85%A8%E6%95%B4%E6%95%B0"><span class="main-content-wrap toc-article-text">安全整数和Number.isSafeInteger() 检查安全整数</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#Math%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95%EF%BC%8C%E6%96%B0%E5%A2%9E17%E4%B8%AA%E5%87%BD%E6%95%B0"><span class="main-content-wrap toc-article-text">Math对象的扩展，新增17个函数</span></a></li></ol></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-1"><a class="main-content-wrap toc-article-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95"><span class="main-content-wrap toc-article-text">数组的扩展</span></a><ol class="main-content-wrap toc-article-child"><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#Array-from-%E8%BD%AC%E6%8D%A2%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E8%87%B3%E7%9C%9F%E6%AD%A3%E7%9A%84%E6%95%B0%E7%BB%84"><span class="main-content-wrap toc-article-text">Array.from() 转换类数组对象至真正的数组</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#Array-of-%E5%B0%86%E4%B8%80%E7%BB%84%E5%80%BC%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E7%BB%84"><span class="main-content-wrap toc-article-text">Array.of() 将一组值转换为数组</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#Array-prototype-copyWithin-%E5%B0%86%E6%95%B0%E7%BB%84%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E6%88%90%E5%91%98%E5%A4%8D%E5%88%B6%E5%88%B0%E5%85%B6%E4%BB%96%E4%BD%8D%E7%BD%AE%E5%90%8E%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84"><span class="main-content-wrap toc-article-text">Array.prototype.copyWithin() 将数组指定位置成员复制到其他位置后返回数组</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#Array-prototype-find-%E6%89%BE%E5%87%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%AC%A6%E5%90%88%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%95%B0%E7%BB%84%E6%88%90%E5%91%98"><span class="main-content-wrap toc-article-text">Array.prototype.find() 找出第一个符合条件的数组成员</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#Array-prototype-findIndex-%E8%BF%94%E5%9B%9E%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%AC%A6%E5%90%88%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%95%B0%E7%BB%84%E6%88%90%E5%91%98%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="main-content-wrap toc-article-text">Array.prototype.findIndex() 返回第一个符合条件的数组成员的位置</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#Array-prototype-fill-%E7%94%A8%E6%8C%87%E5%AE%9A%E5%80%BC%E5%A1%AB%E5%85%85%E6%95%B0%E7%BB%84"><span class="main-content-wrap toc-article-text">Array.prototype.fill() 用指定值填充数组</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#Array-prototype-entries-keys-values-%E7%94%A8%E4%BA%8E%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E5%B9%B6%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E9%81%8D%E5%8E%86%E5%99%A8%E5%AF%B9%E8%B1%A1"><span class="main-content-wrap toc-article-text">Array.prototype.entries()&#x2F;keys()&#x2F;values() 用于遍历数组并返回一个遍历器对象</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#Array-prototype-includes-%E6%A3%80%E6%9F%A5%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E7%BB%99%E5%AE%9A%E7%9A%84%E5%80%BC-%EF%BC%88ES7%EF%BC%89"><span class="main-content-wrap toc-article-text">Array.prototype.includes() 检查数组是否包含给定的值 （ES7）</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E7%A9%BA%E4%BD%8D"><span class="main-content-wrap toc-article-text">数组的空位</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#%E6%95%B0%E7%BB%84%E6%8E%A8%E5%AF%BC-%EF%BC%88ES7%EF%BC%89"><span class="main-content-wrap toc-article-text">数组推导 （ES7）</span></a></li></ol></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-1"><a class="main-content-wrap toc-article-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95"><span class="main-content-wrap toc-article-text">函数的扩展</span></a><ol class="main-content-wrap toc-article-child"><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="main-content-wrap toc-article-text">函数参数的默认值</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84length%E5%B1%9E%E6%80%A7"><span class="main-content-wrap toc-article-text">函数的length属性</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#rest%E5%8F%82%E6%95%B0"><span class="main-content-wrap toc-article-text">rest参数</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="main-content-wrap toc-article-text">扩展运算符</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#name%E5%B1%9E%E6%80%A7-%E8%BF%94%E5%9B%9E%E8%AF%A5%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0%E5%90%8D"><span class="main-content-wrap toc-article-text">name属性 返回该函数的函数名</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="main-content-wrap toc-article-text">箭头函数</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#%E5%87%BD%E6%95%B0%E7%BB%91%E5%AE%9A-ES7"><span class="main-content-wrap toc-article-text">函数绑定 (ES7)</span></a></li></ol></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-1"><a class="main-content-wrap toc-article-link" href="#%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95"><span class="main-content-wrap toc-article-text">对象扩展</span></a><ol class="main-content-wrap toc-article-child"><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E7%AE%80%E6%B4%81%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="main-content-wrap toc-article-text">属性的简洁表示法</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#%E5%B1%9E%E6%80%A7%E5%90%8D%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="main-content-wrap toc-article-text">属性名表达式</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84name%E5%B1%9E%E6%80%A7-%E8%BF%94%E5%9B%9E%E6%96%B9%E6%B3%95%E5%90%8D"><span class="main-content-wrap toc-article-text">方法的name属性 返回方法名</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#Object-is-%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA%E5%80%BC%E6%98%AF%E5%90%A6%E4%B8%A5%E6%A0%BC%E7%9B%B8%E7%AD%89"><span class="main-content-wrap toc-article-text">Object.is() 比较两个值是否严格相等</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#Object-assign-%E5%B0%86%E6%BA%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%80%E6%9C%89%E5%8F%AF%E6%9E%9A%E4%B8%BE%E5%B1%9E%E6%80%A7%EF%BC%8C%E5%A4%8D%E5%88%B6%E5%88%B0%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E4%B8%8A"><span class="main-content-wrap toc-article-text">Object.assign() 将源对象的所有可枚举属性，复制到目标对象上</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8F%AF%E6%9E%9A%E4%B8%BE%E6%80%A7"><span class="main-content-wrap toc-article-text">属性的可枚举性</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E9%81%8D%E5%8E%86"><span class="main-content-wrap toc-article-text">属性的遍历</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#proto%E5%B1%9E%E6%80%A7%EF%BC%8CObject-setPrototypeOf-%EF%BC%8CObject-getPrototypeOf"><span class="main-content-wrap toc-article-text">proto属性，Object.setPrototypeOf()，Object.getPrototypeOf()</span></a></li></ol></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-1"><a class="main-content-wrap toc-article-link" href="#%E6%96%B0%E7%9A%84%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8BSymbol"><span class="main-content-wrap toc-article-text">新的原始数据类型Symbol</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-1"><a class="main-content-wrap toc-article-link" href="#Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="main-content-wrap toc-article-text">Set和Map数据结构</span></a><ol class="main-content-wrap toc-article-child"><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#Set-prototype-add-value-%E6%B7%BB%E5%8A%A0%E6%9F%90%E4%B8%AA%E5%80%BC"><span class="main-content-wrap toc-article-text">Set.prototype.add(value) 添加某个值</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#Set-prototype-delete-value-%E5%88%A0%E9%99%A4%E6%9F%90%E4%B8%AA%E5%80%BC"><span class="main-content-wrap toc-article-text">Set.prototype.delete(value) 删除某个值</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#Set-prototype-has-value-%E6%A3%80%E6%9F%A5%E8%AF%A5%E5%80%BC%E6%98%AF%E5%90%A6%E4%B8%BASet%E7%9A%84%E6%88%90%E5%91%98"><span class="main-content-wrap toc-article-text">Set.prototype.has(value) 检查该值是否为Set的成员</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#Set-prototype-clear-%E6%B8%85%E9%99%A4%E6%89%80%E6%9C%89%E6%88%90%E5%91%98"><span class="main-content-wrap toc-article-text">Set.prototype.clear() 清除所有成员</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#Map-prototype-size-%E6%88%90%E5%91%98%E6%80%BB%E6%95%B0"><span class="main-content-wrap toc-article-text">Map.prototype.size 成员总数</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#Map-prototype-set-key-value-%E8%AE%BE%E7%BD%AEkey%E6%89%80%E5%AF%B9%E5%BA%94%E7%9A%84%E9%94%AE%E5%80%BC"><span class="main-content-wrap toc-article-text">Map.prototype.set(key, value) 设置key所对应的键值</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#Map-prototype-get-key-%E8%AF%BB%E5%8F%96key%E5%AF%B9%E5%BA%94%E7%9A%84%E9%94%AE%E5%80%BC"><span class="main-content-wrap toc-article-text">Map.prototype.get(key) 读取key对应的键值</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#Map-prototype-has-key-%E6%A3%80%E6%9F%A5%E6%9F%90%E4%B8%AA%E9%94%AE%E6%98%AF%E5%90%A6%E5%9C%A8Map%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD"><span class="main-content-wrap toc-article-text">Map.prototype.has(key) 检查某个键是否在Map数据结构中</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#Map-prototype-delete-key-%E5%88%A0%E9%99%A4%E6%9F%90%E4%B8%AA%E9%94%AE"><span class="main-content-wrap toc-article-text">Map.prototype.delete(key) 删除某个键</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#Map-prototype-clear-%E6%B8%85%E9%99%A4%E6%89%80%E6%9C%89%E6%88%90%E5%91%98"><span class="main-content-wrap toc-article-text">Map.prototype.clear() 清除所有成员</span></a></li></ol></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-1"><a class="main-content-wrap toc-article-link" href="#Iterator%E5%92%8Cfor%E2%80%A6of%E5%BE%AA%E7%8E%AF"><span class="main-content-wrap toc-article-text">Iterator和for…of循环</span></a><ol class="main-content-wrap toc-article-child"><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#Iterator%EF%BC%88%E9%81%8D%E5%8E%86%E5%99%A8%EF%BC%89"><span class="main-content-wrap toc-article-text">Iterator（遍历器）</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#for%E2%80%A6of%E5%BE%AA%E7%8E%AF"><span class="main-content-wrap toc-article-text">for…of循环</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E9%81%8D%E5%8E%86%E8%AF%AD%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83"><span class="main-content-wrap toc-article-text">与其他遍历语法的比较</span></a></li></ol></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-1"><a class="main-content-wrap toc-article-link" href="#Class"><span class="main-content-wrap toc-article-text">Class</span></a><ol class="main-content-wrap toc-article-child"><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#Class%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="main-content-wrap toc-article-text">Class表达式</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#Class%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="main-content-wrap toc-article-text">Class的继承</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#%E5%8E%9F%E7%94%9F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="main-content-wrap toc-article-text">原生构造函数的继承</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#Class%E7%9A%84%E5%8F%96%E5%80%BC%E5%87%BD%E6%95%B0%EF%BC%88getter%EF%BC%89%E5%92%8C%E5%AD%98%E5%80%BC%E5%87%BD%E6%95%B0%EF%BC%88setter%EF%BC%89"><span class="main-content-wrap toc-article-text">Class的取值函数（getter）和存值函数（setter）</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#Class%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="main-content-wrap toc-article-text">Class的静态方法</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#Class%E7%9A%84%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="main-content-wrap toc-article-text">Class的静态属性和实例属性</span></a></li></ol></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-1"><a class="main-content-wrap toc-article-link" href="#Module"><span class="main-content-wrap toc-article-text">Module</span></a><ol class="main-content-wrap toc-article-child"><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#export"><span class="main-content-wrap toc-article-text">export</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#import"><span class="main-content-wrap toc-article-text">import</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E6%95%B4%E4%BD%93%E5%8A%A0%E8%BD%BD"><span class="main-content-wrap toc-article-text">模块的整体加载</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#export-default%E5%91%BD%E4%BB%A4"><span class="main-content-wrap toc-article-text">export default命令</span></a></li></ol></li></ol>
    <div class="post-content markdown" itemprop="articleBody">
        <div class="main-content-wrap">
            <p>本文是阮一峰书籍<a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">《ECMAScript 6 入门》</a>的读书笔记，并进行了精简和整合，用20%的篇幅覆盖80%的功能，可以用来速查ES6知识。</p>
<a id="more"></a>
<h1 id="let-与-const"><a href="#let-与-const" class="headerlink" title="let 与 const"></a>let 与 const</h1><p>let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。</p>
<ul>
<li>let不像var那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。</li>
<li>只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</li>
<li>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。</li>
<li>let不允许在相同作用域内，重复声明同一个变量。</li>
<li>ES6也规定，函数本身的作用域，在其所在的块级作用域之内。内部声明的函数皆不会影响到作用域的外部。</li>
</ul>
<p>const也用来声明变量，但是声明的是常量。一旦声明，常量的值就不能改变。</p>
<ul>
<li>const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</li>
<li>const声明的常量，也与let一样不可重复声明。</li>
<li>对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。如果真的想将对象冻结，应该使用Object.freeze方法。</li>
</ul>
<p>ES6一方面规定，var命令和function命令声明的全局变量，依旧是全局对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。</p>
<hr>
<h1 id="变量解构赋值"><a href="#变量解构赋值" class="headerlink" title="变量解构赋值"></a>变量解构赋值</h1><p>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。只要等号两边的模式相同，左边的变量就会被赋予对应的值。如果解构不成功，变量的值就等于undefined。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let [foo, <span class="string">[[bar], baz]]</span> = [<span class="number">1</span>, <span class="string">[[2], 3]]</span>;</div></pre></td></tr></table></figure>
<p>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">x <span class="comment">// 1</span></div><div class="line">y <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>解构赋值适用于var、let、const命令、Set结构。事实上，只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。</p>
<p>解构赋值允许指定默认值。如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">var</span> [foo = <span class="literal">true</span>] = [];</div><div class="line"><span class="attribute">foo</span> // <span class="literal">true</span></div></pre></td></tr></table></figure>
<p>解构不仅可以用于数组，还可以用于对象。对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。如果变量名与属性名不一致，必须写成下面这样。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var &#123; <span class="string">foo:</span> baz &#125; = &#123; <span class="string">foo:</span> <span class="string">"aaa"</span>, <span class="string">bar:</span> <span class="string">"bbb"</span> &#125;;</div><div class="line">baz <span class="comment">// "aaa"</span></div><div class="line"></div><div class="line">let obj = &#123; <span class="string">first:</span> <span class="string">'hello'</span>, <span class="string">last:</span> <span class="string">'world'</span> &#125;;</div><div class="line">let &#123; <span class="string">first:</span> f, <span class="string">last:</span> l &#125; = obj;</div><div class="line">f <span class="comment">// 'hello'</span></div><div class="line">l <span class="comment">// 'world'</span></div></pre></td></tr></table></figure>
<p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const [a, b, c, d, e] = <span class="string">'hello'</span>;</div><div class="line">a <span class="regexp">//</span> <span class="string">"h"</span></div><div class="line">b <span class="regexp">//</span> <span class="string">"e"</span></div><div class="line">c <span class="regexp">//</span> <span class="string">"l"</span></div><div class="line">d <span class="regexp">//</span> <span class="string">"l"</span></div><div class="line">e <span class="regexp">//</span> <span class="string">"o"</span></div></pre></td></tr></table></figure></p>
<p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。解构赋值的规则是，只要等号右边的值不是对象，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。</p>
<p>函数的参数也可以使用解构赋值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> x + y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">add([<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">// 3</span></div></pre></td></tr></table></figure></p>
<p>以下三种解构赋值不得使用圆括号。可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</p>
<ul>
<li>变量声明语句中，模式不能带有圆括号。</li>
<li>函数参数中，模式不能带有圆括号。</li>
<li>不能将整个模式，或嵌套模式中的一层，放在圆括号之中。</li>
</ul>
<p>主要用途：</p>
<ul>
<li>交换变量的值 <code>[x, y] = [y, x]</code></li>
<li><p>从函数返回多个值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> [a, b, c] = example();</div></pre></td></tr></table></figure>
</li>
<li><p>函数参数的定义</p>
</li>
<li>提取JSON数据</li>
<li>函数参数的默认值</li>
<li>遍历Map结构</li>
<li>输入模块的指定方法</li>
</ul>
<hr>
<h1 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h1><h2 id="字符的Unicode表示法"><a href="#字符的Unicode表示法" class="headerlink" title="字符的Unicode表示法"></a>字符的Unicode表示法</h2><p>JavaScript允许采用\uxxxx形式表示一个字符，其中“xxxx”表示字符的码点。但是，这种表示法只限于\u0000——\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表达。如果直接在“\u”后面跟上超过0xFFFF的数值（比如\u20BB7），JavaScript会理解成“\u20BB+7”。ES6对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。`\u{20BB7</p>
<h2 id="codePointAt-返回字符码点"><a href="#codePointAt-返回字符码点" class="headerlink" title="codePointAt() 返回字符码点"></a>codePointAt() 返回字符码点</h2><p>正确处理4个字节储存的字符，返回一个字符的码点。charCodeAt()的升级版。</p>
<h2 id="String-fromCodePoint-从码点返回字符"><a href="#String-fromCodePoint-从码点返回字符" class="headerlink" title="String.fromCodePoint() 从码点返回字符"></a>String.fromCodePoint() 从码点返回字符</h2><p>正确识别大于0xFFFF的码点，从码点返回对应字符。fromCharCode()的升级版。</p>
<h2 id="字符串的遍历器接口"><a href="#字符串的遍历器接口" class="headerlink" title="字符串的遍历器接口"></a>字符串的遍历器接口</h2><p>ES6为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被for…of循环遍历。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> codePoint <span class="keyword">of</span> <span class="string">'foo'</span>) &#123;</div><div class="line">  <span class="built_in">console</span>.log(codePoint)</div><div class="line">&#125;</div><div class="line"><span class="comment">// "f"</span></div><div class="line"><span class="comment">// "o"</span></div><div class="line"><span class="comment">// "o"</span></div></pre></td></tr></table></figure></p>
<p>这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。</p>
<h2 id="at-返回指定位置字符"><a href="#at-返回指定位置字符" class="headerlink" title="at() 返回指定位置字符"></a>at() 返回指定位置字符</h2><p>返回字符串给定位置的字符，可以识别Unicode编号大于0xFFFF的字符。charAt的升级版。</p>
<h2 id="normalize-统一字符"><a href="#normalize-统一字符" class="headerlink" title="normalize() 统一字符"></a>normalize() 统一字符</h2><p>将字符的不同表示方法统一为同样的形式，这称为Unicode正规化。</p>
<h2 id="includes-startsWith-endsWith-确定一个字符串是否包含在另一个字符串中"><a href="#includes-startsWith-endsWith-确定一个字符串是否包含在另一个字符串中" class="headerlink" title="includes(), startsWith(), endsWith() 确定一个字符串是否包含在另一个字符串中"></a>includes(), startsWith(), endsWith() 确定一个字符串是否包含在另一个字符串中</h2><p>indexOf的升级，用来确定一个字符串是否包含在另一个字符串中。</p>
<ul>
<li>includes()：返回布尔值，表示是否找到了参数字符串。</li>
<li>startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。</li>
<li>endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。</li>
</ul>
<h2 id="repeat-重复原字符串"><a href="#repeat-重复原字符串" class="headerlink" title="repeat() 重复原字符串"></a>repeat() 重复原字符串</h2><p>repeat方法返回一个新字符串，表示将原字符串重复n次。 <code>&#39;hello&#39;.repeat(2) // &quot;hellohello&quot;</code></p>
<h2 id="padStart-，padEnd-通过指定字符串补全原字符串到指定长度"><a href="#padStart-，padEnd-通过指定字符串补全原字符串到指定长度" class="headerlink" title="padStart()，padEnd() 通过指定字符串补全原字符串到指定长度"></a>padStart()，padEnd() 通过指定字符串补全原字符串到指定长度</h2><p>ES7推出了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart用于头部补全，padEnd用于尾部补全。一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。</p>
<h2 id="String-raw-返回斜杠被转义的字符串"><a href="#String-raw-返回斜杠被转义的字符串" class="headerlink" title="String.raw() 返回斜杠被转义的字符串"></a>String.raw() 返回斜杠被转义的字符串</h2><p>String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。</p>
<h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 普通字符串</span></div><div class="line">`<span class="built_in">In</span> JavaScript <span class="string">'\n'</span> is a line-feed.`</div><div class="line"></div><div class="line"><span class="comment">// 多行字符串</span></div><div class="line">`<span class="built_in">In</span> JavaScript this is</div><div class="line"> <span class="built_in">not</span> legal.`</div><div class="line"></div><div class="line">console.<span class="built_in">log</span>(`string <span class="built_in">text</span> line <span class="number">1</span></div><div class="line">string <span class="built_in">text</span> line <span class="number">2</span>`);</div><div class="line"></div><div class="line"><span class="comment">// 字符串中嵌入变量</span></div><div class="line">var <span class="built_in">name</span> = <span class="string">"Bob"</span>, <span class="built_in">time</span> = <span class="string">"today"</span>;</div><div class="line">`Hello $&#123;<span class="built_in">name</span>&#125;, how are you $&#123;<span class="built_in">time</span>&#125;?`</div></pre></td></tr></table></figure>
<ul>
<li>如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</li>
<li>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。</li>
<li>模板字符串中嵌入变量，需要将变量名写在${}之中。大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。模板字符串之中还能调用函数。</li>
</ul>
<h2 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h2><p>模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</div><div class="line"></div><div class="line">tag`Hello $&#123; a + b &#125; world $&#123; a * b &#125;`;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span><span class="params">(stringArr, <span class="rest_arg">...values</span>)</span></span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h1 id="正则扩展"><a href="#正则扩展" class="headerlink" title="正则扩展"></a>正则扩展</h1><h2 id="RegExp构造函数"><a href="#RegExp构造函数" class="headerlink" title="RegExp构造函数"></a>RegExp构造函数</h2><p>ES6允许RegExp构造函数接受正则表达式作为参数，这时会返回一个原有正则表达式的拷贝。如果使用RegExp构造函数的第二个参数指定修饰符，则返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/abc/ig</span>, <span class="string">'i'</span>).flags</div><div class="line"><span class="comment">// "i"</span></div></pre></td></tr></table></figure>
<h2 id="u修饰符"><a href="#u修饰符" class="headerlink" title="u修饰符"></a>u修饰符</h2><p>ES6对正则表达式添加了u修饰符，含义为“Unicode模式”，用来正确处理大于\uFFFF的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码。</p>
<h2 id="y修饰符"><a href="#y修饰符" class="headerlink" title="y修饰符"></a>y修饰符</h2><p>ES6还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var s = <span class="string">"aaa_aa_a"</span><span class="comment">;</span></div><div class="line">var <span class="built_in">r1</span> = /a+/g<span class="comment">;</span></div><div class="line">var <span class="built_in">r2</span> = /a+/<span class="built_in">y</span><span class="comment">;</span></div><div class="line"></div><div class="line"><span class="built_in">r1</span>.exec(s) // [<span class="string">"aaa"</span>]</div><div class="line"><span class="built_in">r2</span>.exec(s) // [<span class="string">"aaa"</span>]</div><div class="line"></div><div class="line"><span class="built_in">r1</span>.exec(s) // [<span class="string">"aa"</span>]</div><div class="line"><span class="built_in">r2</span>.exec(s) // null</div><div class="line"></div><div class="line">var <span class="built_in">r3</span> = /a+_/<span class="built_in">y</span><span class="comment">;</span></div><div class="line"><span class="built_in">r3</span>.exec(s) // [<span class="string">"aaa_"</span>]</div><div class="line"><span class="built_in">r3</span>.exec(s) // [<span class="string">"aa_"</span>]</div></pre></td></tr></table></figure>
<p>与y修饰符相匹配，ES6的正则对象多了sticky属性，表示是否设置了y修饰符。</p>
<h2 id="flags属性"><a href="#flags属性" class="headerlink" title="flags属性"></a>flags属性</h2><p>ES6为正则表达式新增了flags属性，会返回正则表达式的修饰符。</p>
<hr>
<h1 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h1><h2 id="二进制和八进制表示法"><a href="#二进制和八进制表示法" class="headerlink" title="二进制和八进制表示法"></a>二进制和八进制表示法</h2><p>ES6提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。如果要将0b和0x前缀的字符串数值转为十进制，要使用Number方法。</p>
<h2 id="Number-isFinite-Number-isNaN-检查Infinite与NaN"><a href="#Number-isFinite-Number-isNaN-检查Infinite与NaN" class="headerlink" title="Number.isFinite(), Number.isNaN() 检查Infinite与NaN"></a>Number.isFinite(), Number.isNaN() 检查Infinite与NaN</h2><p>ES6在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法，用来检查Infinite和NaN这两个特殊值。</p>
<h2 id="Number-parseInt-Number-parseFloat"><a href="#Number-parseInt-Number-parseFloat" class="headerlink" title="Number.parseInt(), Number.parseFloat()"></a>Number.parseInt(), Number.parseFloat()</h2><p>ES6将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。</p>
<h2 id="Number-isInteger-判断一个值是否为整数"><a href="#Number-isInteger-判断一个值是否为整数" class="headerlink" title="Number.isInteger() 判断一个值是否为整数"></a>Number.isInteger() 判断一个值是否为整数</h2><p>Number.isInteger()用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。</p>
<h2 id="Number-EPSILON-极小常量，用于判断误差"><a href="#Number-EPSILON-极小常量，用于判断误差" class="headerlink" title="Number.EPSILON 极小常量，用于判断误差"></a>Number.EPSILON 极小常量，用于判断误差</h2><p>ES6在Number对象上面，新增一个极小的常量Number.EPSILON。引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。但是如果这个误差能够小于Number.EPSILON，我们就可以认为得到了正确结果。因此，Number.EPSILON的实质是一个可以接受的误差范围。</p>
<h2 id="安全整数和Number-isSafeInteger-检查安全整数"><a href="#安全整数和Number-isSafeInteger-检查安全整数" class="headerlink" title="安全整数和Number.isSafeInteger() 检查安全整数"></a>安全整数和Number.isSafeInteger() 检查安全整数</h2><p>JavaScript能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。ES6引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。</p>
<h2 id="Math对象的扩展，新增17个函数"><a href="#Math对象的扩展，新增17个函数" class="headerlink" title="Math对象的扩展，新增17个函数"></a>Math对象的扩展，新增17个函数</h2><ul>
<li>Math.trunc方法用于去除一个数的小数部分，返回整数部分。</li>
<li>Math.sign方法用来判断一个数到底是正数、负数、还是零。</li>
<li>Math.cbrt方法用于计算一个数的立方根。</li>
<li>JavaScript的整数使用32位二进制形式表示，Math.clz32方法返回一个数的32位无符号整数形式有多少个前导0。</li>
<li>Math.imul方法返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数。</li>
<li>Math.fround方法返回一个数的单精度浮点数形式。</li>
<li>Math.hypot方法返回所有参数的平方和的平方根。</li>
<li>Math.expm1(x)返回ex - 1，即Math.exp(x) - 1。</li>
<li>Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。</li>
<li>Math.log10(x)返回以10为底的x的对数。如果x小于0，则返回NaN。</li>
<li>Math.log2(x)返回以2为底的x的对数。如果x小于0，则返回NaN。</li>
<li>Math.sinh(x) 返回x的双曲正弦（hyperbolic sine）。</li>
<li>Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine）。</li>
<li>Math.tanh(x) 返回x的双曲正切（hyperbolic tangent）。</li>
<li>Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine）。</li>
<li>Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine）。</li>
<li>Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent）。</li>
</ul>
<hr>
<h1 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h1><h2 id="Array-from-转换类数组对象至真正的数组"><a href="#Array-from-转换类数组对象至真正的数组" class="headerlink" title="Array.from() 转换类数组对象至真正的数组"></a>Array.from() 转换类数组对象至真正的数组</h2><p>Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。</p>
<ul>
<li>值得提醒的是，扩展运算符（…）也可以将某些数据结构转为数组。</li>
<li>对于还没有部署该方法的浏览器，可以用Array.prototype.slice方法替代。</li>
<li>Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种Unicode字符，可以避免JavaScript将大于\uFFFF的Unicode字符，算作两个字符的bug。</li>
</ul>
<h2 id="Array-of-将一组值转换为数组"><a href="#Array-of-将一组值转换为数组" class="headerlink" title="Array.of() 将一组值转换为数组"></a>Array.of() 将一组值转换为数组</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Array.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></div></pre></td></tr></table></figure>
<p>这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。</p>
<h2 id="Array-prototype-copyWithin-将数组指定位置成员复制到其他位置后返回数组"><a href="#Array-prototype-copyWithin-将数组指定位置成员复制到其他位置后返回数组" class="headerlink" title="Array.prototype.copyWithin() 将数组指定位置成员复制到其他位置后返回数组"></a>Array.prototype.copyWithin() 将数组指定位置成员复制到其他位置后返回数组</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>)</div><div class="line"><span class="comment">// [4, 5, 3, 4, 5]</span></div></pre></td></tr></table></figure>
<p>它接受三个参数。</p>
<ul>
<li>target（必需）：从该位置开始替换数据。</li>
<li>start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</li>
</ul>
<h2 id="Array-prototype-find-找出第一个符合条件的数组成员"><a href="#Array-prototype-find-找出第一个符合条件的数组成员" class="headerlink" title="Array.prototype.find() 找出第一个符合条件的数组成员"></a>Array.prototype.find() 找出第一个符合条件的数组成员</h2><p>数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">10</span>].find((n) =&gt; n &lt; <span class="number">0</span>)</div><div class="line"><span class="comment">// -5</span></div></pre></td></tr></table></figure>
<h2 id="Array-prototype-findIndex-返回第一个符合条件的数组成员的位置"><a href="#Array-prototype-findIndex-返回第一个符合条件的数组成员的位置" class="headerlink" title="Array.prototype.findIndex() 返回第一个符合条件的数组成员的位置"></a>Array.prototype.findIndex() 返回第一个符合条件的数组成员的位置</h2><p>用法与find方法非常类似。</p>
<h2 id="Array-prototype-fill-用指定值填充数组"><a href="#Array-prototype-fill-用指定值填充数组" class="headerlink" title="Array.prototype.fill() 用指定值填充数组"></a>Array.prototype.fill() 用指定值填充数组</h2><p>fill方法使用给定值，填充一个数组。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="symbol">'a</span>', <span class="symbol">'b</span>', <span class="symbol">'c</span>'].fill(<span class="name">7</span>)</div><div class="line">// [<span class="name">7</span>, <span class="number">7</span>, <span class="number">7</span>]</div></pre></td></tr></table></figure>
<h2 id="Array-prototype-entries-keys-values-用于遍历数组并返回一个遍历器对象"><a href="#Array-prototype-entries-keys-values-用于遍历数组并返回一个遍历器对象" class="headerlink" title="Array.prototype.entries()/keys()/values() 用于遍历数组并返回一个遍历器对象"></a>Array.prototype.entries()/keys()/values() 用于遍历数组并返回一个遍历器对象</h2><p>ES6提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].keys()) &#123;</div><div class="line">  <span class="built_in">console</span>.log(index);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 0</span></div><div class="line"><span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].values()) &#123;</div><div class="line">  <span class="built_in">console</span>.log(elem);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 'a'</span></div><div class="line"><span class="comment">// 'b'</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123;</div><div class="line">  <span class="built_in">console</span>.log(index, elem);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 0 "a"</span></div><div class="line"><span class="comment">// 1 "b"</span></div></pre></td></tr></table></figure>
<h2 id="Array-prototype-includes-检查数组是否包含给定的值-（ES7）"><a href="#Array-prototype-includes-检查数组是否包含给定的值-（ES7）" class="headerlink" title="Array.prototype.includes() 检查数组是否包含给定的值 （ES7）"></a>Array.prototype.includes() 检查数组是否包含给定的值 （ES7）</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>);     <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h2 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h2><p>数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。<code>Array(3) // [, , ,]</code></p>
<p>ES5对空位的处理，已经很不一致了，大多数情况下会忽略空位。</p>
<ul>
<li>forEach(), filter(), every() 和some()都会跳过空位。</li>
<li>map()会跳过空位，但会保留这个值</li>
<li>join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。</li>
</ul>
<p>ES6则是明确将空位转为undefined。</p>
<ul>
<li>Array.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。</li>
<li>扩展运算符（…）也会将空位转为undefined。</li>
<li>copyWithin()会连空位一起拷贝。</li>
<li>fill()会将空位视为正常的数组位置。</li>
<li>for…of循环也会遍历空位。</li>
<li>entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。</li>
</ul>
<p>由于空位的处理规则非常不统一，所以建议避免出现空位。</p>
<h2 id="数组推导-（ES7）"><a href="#数组推导-（ES7）" class="headerlink" title="数组推导 （ES7）"></a>数组推导 （ES7）</h2><p>数组推导（array comprehension）提供简洁写法，允许直接通过现有数组生成新数组。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line">var a2 = [for (i of a1) i * <span class="number">2</span>];</div><div class="line"></div><div class="line">a2 <span class="comment">// [2, 4, 6, 8]</span></div></pre></td></tr></table></figure>
<hr>
<h1 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h1><h2 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h2><p>ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y = <span class="string">'World'</span></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(x, y);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>默认声明的参数变量在函数体中不能用let或const再次声明，否则会报错。</p>
<p>参数默认值可以与解构赋值的默认值，结合起来使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125;</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(x, y);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果传入undefined，将触发该参数等于默认值，null则没有这个效果。</p>
<h2 id="函数的length属性"><a href="#函数的length属性" class="headerlink" title="函数的length属性"></a>函数的length属性</h2><p>指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(function(a)&#123;&#125;)<span class="selector-class">.length</span> <span class="comment">// 1</span></div><div class="line">(function(<span class="selector-tag">a</span> = <span class="number">5</span>)&#123;&#125;)<span class="selector-class">.length</span> <span class="comment">// 0</span></div><div class="line">(function(<span class="selector-tag">a</span>, <span class="selector-tag">b</span>, c = <span class="number">5</span>)&#123;&#125;)<span class="selector-class">.length</span> <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>一个需要注意的地方是，如果参数默认值是一个变量，则该变量所处的作用域，与其他变量的作用域规则是一样的，即先是当前函数的作用域，然后才是全局作用域。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y = x</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> x = <span class="number">2</span>;</div><div class="line">  <span class="built_in">console</span>.log(y);</div><div class="line">&#125;</div><div class="line"></div><div class="line">f() <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<h2 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h2><p>ES6引入rest参数（形式为“…变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(<span class="rest_arg">...values</span>)</span> </span>&#123;</div><div class="line">  let sum = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val of values) &#123;</div><div class="line">    sum += val;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"></div><div class="line">add(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10</span></div></pre></td></tr></table></figure>
<h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><p>扩展运算符（spread）是三个点（…）。它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">console.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line"><span class="comment">// 1 2 3</span></div><div class="line"></div><div class="line">console.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)</div><div class="line"><span class="comment">// 1 2 3 4 5</span></div></pre></td></tr></table></figure>
<p>可替代数组的apply方法。</p>
<p>应用：</p>
<ul>
<li>合并数组 <code>[1, 2, ...more]</code></li>
<li>与解构赋值结合 <code>[a, ...rest] = list</code></li>
<li>与函数返回值结合</li>
<li>将字符串转为真正的数组，能够正确识别32位的Unicode字符。</li>
<li>任何Iterator接口的对象，都可以用扩展运算符转为真正的数组。</li>
</ul>
<h2 id="name属性-返回该函数的函数名"><a href="#name属性-返回该函数的函数名" class="headerlink" title="name属性 返回该函数的函数名"></a>name属性 返回该函数的函数名</h2><p>函数的name属性，返回该函数的函数名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">foo.name <span class="comment">// "foo"</span></div></pre></td></tr></table></figure>
<ul>
<li>Function构造函数返回的函数实例，name属性的值为“anonymous”。</li>
<li>bind返回的函数，name属性值会加上“bound ”前缀。</li>
</ul>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>ES6允许使用“箭头”（=&gt;）定义函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</div><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> v;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</li>
<li>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。</li>
<li>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上圆括号。</li>
<li>箭头函数可以与变量解构结合使用。</li>
<li>箭头函数可以与rest参数结合使用。</li>
</ul>
<p>箭头函数有几个使用注意点:</p>
<ul>
<li>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</li>
<li>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</li>
<li>不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。</li>
<li>不可以使用yield命令，因此箭头函数不能用作Generator函数。</li>
</ul>
<h2 id="函数绑定-ES7"><a href="#函数绑定-ES7" class="headerlink" title="函数绑定 (ES7)"></a>函数绑定 (ES7)</h2><p>箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以ES7提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。虽然该语法还是ES7的一个提案，但是Babel转码器已经支持。</p>
<p>函数绑定运算符是并排的两个双冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">foo::<span class="built_in">bar</span>;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="built_in">bar</span>.bind(foo);</div><div class="line"></div><div class="line">foo::<span class="built_in">bar</span>(...arguments);</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="built_in">bar</span>.apply(foo, arguments);</div></pre></td></tr></table></figure>
<h1 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h1><h2 id="属性的简洁表示法"><a href="#属性的简洁表示法" class="headerlink" title="属性的简洁表示法"></a>属性的简洁表示法</h2><p>ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> birth = <span class="string">'2000/01/01'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> Person = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'张三'</span>,</div><div class="line">  <span class="comment">//等同于birth: birth</span></div><div class="line">  birth,</div><div class="line">  <span class="comment">// 等同于hello: function ()...</span></div><div class="line">  hello() &#123; <span class="built_in">console</span>.log(<span class="string">'我的名字是'</span>, <span class="keyword">this</span>.name); &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h2><p>ES6允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">let propKey</span> = <span class="string">'foo'</span>;</div><div class="line"></div><div class="line"><span class="attribute">let obj</span> = &#123;</div><div class="line">  [propKey]: true,</div><div class="line">  [<span class="string">'a'</span> + <span class="string">'bc'</span>]: 123</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>注意，属性名表达式与简洁表示法，不能同时使用，会报错。</p>
<h2 id="方法的name属性-返回方法名"><a href="#方法的name属性-返回方法名" class="headerlink" title="方法的name属性 返回方法名"></a>方法的name属性 返回方法名</h2><p>函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。</p>
<h2 id="Object-is-比较两个值是否严格相等"><a href="#Object-is-比较两个值是否严格相等" class="headerlink" title="Object.is() 比较两个值是否严格相等"></a>Object.is() 比较两个值是否严格相等</h2><p>ES6提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p>
<p>不同之处只有两个：一是+0不等于-0，二是NaN等于自身。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+<span class="number">0</span> === <span class="number">-0</span> <span class="comment">//true</span></div><div class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>) <span class="comment">// false</span></div><div class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h2 id="Object-assign-将源对象的所有可枚举属性，复制到目标对象上"><a href="#Object-assign-将源对象的所有可枚举属性，复制到目标对象上" class="headerlink" title="Object.assign() 将源对象的所有可枚举属性，复制到目标对象上"></a>Object.assign() 将源对象的所有可枚举属性，复制到目标对象上</h2><p>Object.assign方法用来将源对象（source）的所有可枚举属性，复制到目标对象（target）。它至少需要两个对象作为参数，第一个参数是目标对象，后面的参数都是源对象。只要有一个参数不是对象，就会抛出TypeError错误。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> target = <span class="comment">&#123; a: 1 &#125;</span>;</div><div class="line"><span class="keyword">var</span> source1 = <span class="comment">&#123; b: 2 &#125;</span>;</div><div class="line"><span class="keyword">var</span> source2 = <span class="comment">&#123; c: 3 &#125;</span>;</div><div class="line"></div><div class="line"><span class="keyword">Object</span>.assign(target, source1, source2);</div><div class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></div></pre></td></tr></table></figure>
<p>用途：</p>
<ul>
<li>为对象添加属性</li>
<li>为对象添加方法</li>
<li>克隆对象</li>
<li>合并多个对象</li>
<li>为属性指定默认值</li>
</ul>
<h2 id="属性的可枚举性"><a href="#属性的可枚举性" class="headerlink" title="属性的可枚举性"></a>属性的可枚举性</h2><p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。</p>
<p>ES5有三个操作会忽略enumerable为false的属性。</p>
<ul>
<li>for…in 循环：只遍历对象自身的和继承的可枚举的属性</li>
<li>Object.keys()：返回对象自身的所有可枚举的属性的键名</li>
<li>JSON.stringify()：只串行化对象自身的可枚举的属性</li>
</ul>
<p>ES6新增了两个操作，会忽略enumerable为false的属性。</p>
<ul>
<li>Object.assign()：只拷贝对象自身的可枚举的属性</li>
<li>Reflect.enumerate()：返回所有for…in循环会遍历的属性</li>
</ul>
<h2 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h2><p>ES6一共有6种方法可以遍历对象的属性。</p>
<ol>
<li><code>for...in</code> for…in循环遍历对象自身的和继承的可枚举属性（不含Symbol属性）。</li>
<li><code>Object.keys(obj)</code>Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）。</li>
<li><code>Object.getOwnPropertyNames(obj)</code>Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）。<br>4.<code>Object.getOwnPropertySymbols(obj)</code>Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有Symbol属性。<br>5.<code>Reflect.ownKeys(obj)</code>Reflect.ownKeys返回一个数组，包含对象自身的所有属性，不管是属性名是Symbol或字符串，也不管是否可枚举。<br>6.<code>Reflect.enumerate(obj)</code>Reflect.enumerate返回一个Iterator对象，遍历对象自身的和继承的所有可枚举属性（不含Symbol属性），与for…in循环相同。</li>
</ol>
<h2 id="proto属性，Object-setPrototypeOf-，Object-getPrototypeOf"><a href="#proto属性，Object-setPrototypeOf-，Object-getPrototypeOf" class="headerlink" title="proto属性，Object.setPrototypeOf()，Object.getPrototypeOf()"></a><strong>proto</strong>属性，Object.setPrototypeOf()，Object.getPrototypeOf()</h2><p><strong>proto</strong>属性（前后各两个下划线），用来读取或设置当前对象的prototype对象。目前，所有浏览器（包括IE11）都部署了这个属性。该属性没有写入ES6的正文，而是写入了附录，原因是<strong>proto</strong>前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的API，只是由于浏览器广泛支持，才被加入了ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。</p>
<p>Object.setPrototypeOf方法的作用与<strong>proto</strong>相同，用来设置一个对象的prototype对象。它是ES6正式推荐的设置原型对象的方法。</p>
<p>Object.getPrototypeOf方法与setPrototypeOf方法配套，用于读取一个对象的prototype对象。</p>
<hr>
<h1 id="新的原始数据类型Symbol"><a href="#新的原始数据类型Symbol" class="headerlink" title="新的原始数据类型Symbol"></a>新的原始数据类型Symbol</h1><p>ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。它是JavaScript语言的第七种数据类型，前六种是：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p>
<p>Symbol值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</div><div class="line"></div><div class="line"><span class="keyword">typeof</span> s</div><div class="line"><span class="comment">// "symbol"</span></div></pre></td></tr></table></figure>
<p>注意，Symbol函数前不能使用new命令，否则会报错。这是因为生成的Symbol是一个原始类型的值，不是对象。也就是说，由于Symbol值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。Symbol函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p>
<p>Symbol值不能与其他类型的值进行运算，会报错。Symbol值可以显式转为字符串和布尔值。</p>
<p>实例：消除魔术字符串</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function getArea(<span class="built_in">shape</span>, options) &#123;</div><div class="line">  var area = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">switch</span> (<span class="built_in">shape</span>) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">'Triangle'</span>: <span class="comment">// 魔术字符串</span></div><div class="line">      area = <span class="number">.5</span> * options.<span class="built_in">width</span> * options.<span class="built_in">height</span>;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="comment">/* ... more code ... */</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> area;</div><div class="line">&#125;</div><div class="line"></div><div class="line">getArea(<span class="string">'Triangle'</span>, &#123; <span class="built_in">width</span>: <span class="number">100</span>, <span class="built_in">height</span>: <span class="number">100</span> &#125;); <span class="comment">// 魔术字符串</span></div></pre></td></tr></table></figure>
<p>上面代码中，字符串“Triangle”就是一个魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。</p>
<p>常用的消除魔术字符串的方法，就是把它写成一个变量。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var shapeType = &#123;</div><div class="line">  <span class="built_in">triangle</span>: <span class="string">'Triangle'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">function getArea(<span class="built_in">shape</span>, options) &#123;</div><div class="line">  var area = <span class="number">0</span>;</div><div class="line">  <span class="keyword">switch</span> (<span class="built_in">shape</span>) &#123;</div><div class="line">    <span class="keyword">case</span> shapeType.<span class="built_in">triangle</span>:</div><div class="line">      area = <span class="number">.5</span> * options.<span class="built_in">width</span> * options.<span class="built_in">height</span>;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> area;</div><div class="line">&#125;</div><div class="line"></div><div class="line">getArea(shapeType.<span class="built_in">triangle</span>, &#123; <span class="built_in">width</span>: <span class="number">100</span>, <span class="built_in">height</span>: <span class="number">100</span> &#125;);</div></pre></td></tr></table></figure>
<p>上面代码中，我们把“Triangle”写成shapeType对象的triangle属性，这样就消除了强耦合。</p>
<p>如果仔细分析，可以发现shapeType.triangle等于哪个值并不重要，只要确保不会跟其他shapeType属性的值冲突即可。因此，这里就很适合改用Symbol值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> shapeType = &#123;</div><div class="line">  <span class="attr">triangle</span>: <span class="built_in">Symbol</span>()</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面代码中，除了将shapeType.triangle的值设为一个Symbol，其他地方都不用修改。</p>
<hr>
<h1 id="Set和Map数据结构"><a href="#Set和Map数据结构" class="headerlink" title="Set和Map数据结构"></a>Set和Map数据结构</h1><p>ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set本身是一个构造函数，用来生成Set数据结构。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line"></div><div class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x))</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;<span class="built_in">console</span>.log(i)&#125;</div><div class="line"><span class="comment">// 2 3 5 4</span></div></pre></td></tr></table></figure>
<p>Set函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="keyword">set</span> = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>])</div><div class="line">[...<span class="keyword">set</span>]</div><div class="line"><span class="comment">// [1, 2, 3, 4]</span></div></pre></td></tr></table></figure>
<p>另外，两个对象总是不相等的。</p>
<p>JavaScript的对象（Object），本质上是键值对的集合（Hash结构），但是只能用字符串当作键。这给它的使用带来了很大的限制。为了解决这个问题，ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line"><span class="keyword">var</span> o = &#123;p: <span class="string">"Hello World"</span>&#125;;</div><div class="line"></div><div class="line">m.<span class="keyword">set</span>(o, <span class="string">"content"</span>)</div><div class="line">m.<span class="keyword">get</span>(o) <span class="comment">// "content"</span></div><div class="line"></div><div class="line">m.has(o) <span class="comment">// true</span></div><div class="line">m.delete(o) <span class="comment">// true</span></div><div class="line">m.has(o) <span class="comment">// false</span></div></pre></td></tr></table></figure>
<h2 id="Set-prototype-add-value-添加某个值"><a href="#Set-prototype-add-value-添加某个值" class="headerlink" title="Set.prototype.add(value) 添加某个值"></a>Set.prototype.add(value) 添加某个值</h2><p>添加某个值，返回Set结构本身。</p>
<h2 id="Set-prototype-delete-value-删除某个值"><a href="#Set-prototype-delete-value-删除某个值" class="headerlink" title="Set.prototype.delete(value) 删除某个值"></a>Set.prototype.delete(value) 删除某个值</h2><p>删除某个值，返回一个布尔值，表示删除是否成功。</p>
<h2 id="Set-prototype-has-value-检查该值是否为Set的成员"><a href="#Set-prototype-has-value-检查该值是否为Set的成员" class="headerlink" title="Set.prototype.has(value) 检查该值是否为Set的成员"></a>Set.prototype.has(value) 检查该值是否为Set的成员</h2><p>返回一个布尔值，表示该值是否为Set的成员。</p>
<h2 id="Set-prototype-clear-清除所有成员"><a href="#Set-prototype-clear-清除所有成员" class="headerlink" title="Set.prototype.clear() 清除所有成员"></a>Set.prototype.clear() 清除所有成员</h2><p>清除所有成员，没有返回值。</p>
<h2 id="Map-prototype-size-成员总数"><a href="#Map-prototype-size-成员总数" class="headerlink" title="Map.prototype.size 成员总数"></a>Map.prototype.size 成员总数</h2><p>size属性返回Map结构的成员总数。</p>
<h2 id="Map-prototype-set-key-value-设置key所对应的键值"><a href="#Map-prototype-set-key-value-设置key所对应的键值" class="headerlink" title="Map.prototype.set(key, value) 设置key所对应的键值"></a>Map.prototype.set(key, value) 设置key所对应的键值</h2><p>set方法设置key所对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新，否则就新生成该键。</p>
<h2 id="Map-prototype-get-key-读取key对应的键值"><a href="#Map-prototype-get-key-读取key对应的键值" class="headerlink" title="Map.prototype.get(key) 读取key对应的键值"></a>Map.prototype.get(key) 读取key对应的键值</h2><p>get方法读取key对应的键值，如果找不到key，返回undefined。</p>
<h2 id="Map-prototype-has-key-检查某个键是否在Map数据结构中"><a href="#Map-prototype-has-key-检查某个键是否在Map数据结构中" class="headerlink" title="Map.prototype.has(key) 检查某个键是否在Map数据结构中"></a>Map.prototype.has(key) 检查某个键是否在Map数据结构中</h2><p>has方法返回一个布尔值，表示某个键是否在Map数据结构中。</p>
<h2 id="Map-prototype-delete-key-删除某个键"><a href="#Map-prototype-delete-key-删除某个键" class="headerlink" title="Map.prototype.delete(key) 删除某个键"></a>Map.prototype.delete(key) 删除某个键</h2><p>delete方法删除某个键，返回true。如果删除失败，返回false。</p>
<h2 id="Map-prototype-clear-清除所有成员"><a href="#Map-prototype-clear-清除所有成员" class="headerlink" title="Map.prototype.clear() 清除所有成员"></a>Map.prototype.clear() 清除所有成员</h2><p>clear方法清除所有成员，没有返回值。</p>
<hr>
<h1 id="Iterator和for…of循环"><a href="#Iterator和for…of循环" class="headerlink" title="Iterator和for…of循环"></a>Iterator和for…of循环</h1><h2 id="Iterator（遍历器）"><a href="#Iterator（遍历器）" class="headerlink" title="Iterator（遍历器）"></a>Iterator（遍历器）</h2><p>遍历器（Iterator）是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p>
<p>Iterator的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是ES6创造了一种新的遍历命令for…of循环，Iterator接口主要供for…of消费。</p>
<p>在ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象、Set和Map结构。</p>
<h2 id="for…of循环"><a href="#for…of循环" class="headerlink" title="for…of循环"></a>for…of循环</h2><p>ES6借鉴C++、Java、C#和Python语言，引入了for…of循环，作为遍历所有数据结构的统一的方法。一个数据结构只要部署了Symbol.iterator属性，就被视为具有iterator接口，就可以用for…of循环遍历它的成员。也就是说，for…of循环内部调用的是数据结构的Symbol.iterator方法。</p>
<p>for…of循环可以使用的范围包括数组、Set和Map结构、某些类似数组的对象（比如arguments对象、DOM NodeList对象）、后文的Generator对象，以及字符串。</p>
<p>for…of循环可以代替数组实例的forEach方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> arr = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</div><div class="line"><span class="keyword">let</span> iterator  = arr[<span class="built_in">Symbol</span>.iterator]();</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> arr) &#123;</div><div class="line">  <span class="built_in">console</span>.log(v); <span class="comment">// red green blue</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> iterator) &#123;</div><div class="line">  <span class="built_in">console</span>.log(v); <span class="comment">// red green blue</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JavaScript原有的for…in循环，只能获得对象的键名，不能直接获取键值。ES6提供for…of循环，允许遍历获得键值。</p>
<h2 id="与其他遍历语法的比较"><a href="#与其他遍历语法的比较" class="headerlink" title="与其他遍历语法的比较"></a>与其他遍历语法的比较</h2><ul>
<li>for循环, 比较麻烦。</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (var <span class="keyword">index</span> = <span class="number">0</span>; <span class="keyword">index</span> &lt; myArray.<span class="built_in">length</span>; <span class="keyword">index</span>++) &#123;</div><div class="line">  console.<span class="built_in">log</span>(myArray[<span class="keyword">index</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>forEach, 无法中途跳出forEach循环，break命令或return命令都不能奏效。</li>
</ul>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">myArray.forEach(<span class="function"><span class="keyword">function</span></span> (<span class="keyword">value</span>) &#123;</div><div class="line">  console.<span class="built_in">log</span>(<span class="keyword">value</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ul>
<li>for…in循环可以遍历数组的键名</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (var <span class="keyword">index</span> <span class="keyword">in</span> myArray) &#123;</div><div class="line">  console.<span class="built_in">log</span>(myArray[<span class="keyword">index</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>for…in循环有几个缺点。</p>
<ul>
<li>数组的键名是数字，但是for…in循环是以字符串作为键名“0”、“1”、“2”等等。</li>
<li>for…in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。</li>
<li>某些情况下，for…in循环会以任意顺序遍历键名。</li>
<li>总之，for…in循环主要是为遍历对象而设计的，不适用于遍历数组。</li>
</ul>
<p>for…of循环相比上面几种做法，有一些显著的优点。</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> <span class="keyword">value</span> <span class="keyword">of</span> myArray) &#123;</div><div class="line">  console.log(<span class="keyword">value</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>有着同for…in一样的简洁语法，但是没有for…in那些缺点。</li>
<li>不同用于forEach方法，它可以与break、continue和return配合使用。</li>
<li>提供了遍历所有数据结构的统一操作接口。</li>
</ul>
<hr>
<h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h1><p>基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>(x, y) &#123;</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">    <span class="keyword">this</span>.y = y;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  toString() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ES5版本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x,y</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.x = x;</div><div class="line">  <span class="keyword">this</span>.y = y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ES6的类，完全可以看作构造函数的另一种写法。</p>
<p>类的内部所有定义的方法，都是不可枚举的（enumerable）。这一点与ES5的行为不一致。类的属性名，可以采用表达式。</p>
<p>生成实例对象的写法，与ES5完全一样，也是使用new命令。</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 报错</span></div><div class="line"><span class="built_in">var</span> <span class="built_in">point</span> = Point(<span class="number">2</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="comment">// 正确</span></div><div class="line"><span class="built_in">var</span> <span class="built_in">point</span> = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</div></pre></td></tr></table></figure>
<h2 id="Class表达式"><a href="#Class表达式" class="headerlink" title="Class表达式"></a>Class表达式</h2><p>与函数一样，Class也可以使用表达式的形式定义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>&#123;</div><div class="line">  getClassName() &#123;</div><div class="line">    <span class="keyword">return</span> Me.name;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在Class的内部代码可用，指代当前类。</p>
<figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> inst = <span class="function"><span class="keyword">new</span> <span class="title">MyClass</span>();</span></div><div class="line"><span class="title">inst</span>.<span class="title">getClassName</span>() <span class="comment">// Me</span></div><div class="line"><span class="title">Me</span>.<span class="title">name</span> <span class="comment">// ReferenceError: Me is not defined</span></div></pre></td></tr></table></figure>
<p>上面代码表示，Me只在Class内部有定义。</p>
<p>如果Class内部没用到的话，可以省略Me，也就是可以写成下面的形式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> </span>&#123; <span class="comment">/* ... */</span> &#125;;</div></pre></td></tr></table></figure>
<p>采用Class表达式，可以写出立即执行的Class。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(name) &#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  sayName() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;(<span class="string">"张三"</span>);</div><div class="line"></div><div class="line">person.sayName(); <span class="comment">// "张三"</span></div></pre></td></tr></table></figure>
<p>Class不存在变量提升（hoist）这一点与ES5完全不同。类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。</p>
<h2 id="Class的继承"><a href="#Class的继承" class="headerlink" title="Class的继承"></a>Class的继承</h2><p>Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</div><div class="line"></div><div class="line">  constructor(x, y, color) &#123;</div><div class="line">    <span class="keyword">super</span>(x, y); <span class="comment">// 调用父类的constructor(x, y)</span></div><div class="line">    <span class="keyword">this</span>.color = color;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  toString() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.color + ' ' + <span class="keyword">super</span>.toString(); <span class="comment">// 调用父类的toString()</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>super关键字，它指代父类的实例。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。</p>
<h2 id="原生构造函数的继承"><a href="#原生构造函数的继承" class="headerlink" title="原生构造函数的继承"></a>原生构造函数的继承</h2><p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript的原生构造函数大致有下面这些。</p>
<ul>
<li>Boolean()</li>
<li>Number()</li>
<li>String()</li>
<li>Array()</li>
<li>Date()</li>
<li>Function()</li>
<li>RegExp()</li>
<li>Error()</li>
<li>Object()</li>
</ul>
<p>以前，这些原生构造函数是无法继承的，比如，不能自己定义一个Array的子类。之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过Array.apply()或者分配给原型对象都不行。</p>
<p>ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。下面是一个继承Array的例子。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</div><div class="line">  constructor(...args) &#123;</div><div class="line">    <span class="keyword">super</span>(...args);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="type">MyArray</span>();</div><div class="line">arr[<span class="number">0</span>] = <span class="number">12</span>;</div><div class="line">arr.length <span class="comment">// 1</span></div><div class="line"></div><div class="line">arr.length = <span class="number">0</span>;</div><div class="line">arr[<span class="number">0</span>] <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<h2 id="Class的取值函数（getter）和存值函数（setter）"><a href="#Class的取值函数（getter）和存值函数（setter）" class="headerlink" title="Class的取值函数（getter）和存值函数（setter）"></a>Class的取值函数（getter）和存值函数（setter）</h2><p>与ES5一样，在Class内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">lass MyClass &#123;</div><div class="line">  constructor() &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">get</span> <span class="title">prop</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'getter'</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">set</span> <span class="title">prop</span>(<span class="params"><span class="keyword">value</span></span>) </span>&#123;</div><div class="line">    console.log(<span class="string">'setter: '</span>+<span class="keyword">value</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> MyClass();</div><div class="line"></div><div class="line">inst.prop = <span class="number">123</span>;</div><div class="line"><span class="comment">// setter: 123</span></div><div class="line"></div><div class="line">inst.prop</div><div class="line"><span class="comment">// 'getter'</span></div></pre></td></tr></table></figure>
<h2 id="Class的静态方法"><a href="#Class的静态方法" class="headerlink" title="Class的静态方法"></a>Class的静态方法</h2><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="title">classMethod</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'hello'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo.classMethod() <span class="comment">// 'hello'</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</div><div class="line">foo.classMethod()</div><div class="line"><span class="comment">// TypeError: undefined is not a function</span></div></pre></td></tr></table></figure>
<h2 id="Class的静态属性和实例属性"><a href="#Class的静态属性和实例属性" class="headerlink" title="Class的静态属性和实例属性"></a>Class的静态属性和实例属性</h2><p>静态属性指的是Class本身的属性，即Class.propname，而不是定义在实例对象（this）上的属性。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Foo &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo.<span class="keyword">prop</span> = 1;</div><div class="line">Foo.<span class="keyword">prop</span> <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p>上面的写法为Foo类定义了一个静态属性prop。</p>
<p>目前，只有这种写法可行，因为ES6明确规定，Class内部只有静态方法，没有静态属性。</p>
<hr>
<h1 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h1><p>在ES6之前，社区制定了一些模块加载方案，最主要的有CommonJS和AMD两种。前者用于服务器，后者用于浏览器。ES6在语言规格的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。</p>
<p>ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。比如，CommonJS模块就是对象，输入时必须查找对象属性。</p>
<p>ES6的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”。</p>
<h2 id="export"><a href="#export" class="headerlink" title="export"></a>export</h2><p>模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。</p>
<p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个JS文件，里面使用export命令输出变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// profile.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> year = <span class="number">1958</span>;</div><div class="line"></div><div class="line"><span class="comment">//另一种写法</span></div><div class="line"><span class="keyword">export</span> &#123;firstName, lastName, year&#125;;</div></pre></td></tr></table></figure>
<p>通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">v1</span>(<span class="params"></span>) </span>&#123; ... &#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">v2</span>(<span class="params"></span>) </span>&#123; ... &#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> &#123;</div><div class="line">  v1 <span class="keyword">as</span> streamV1,</div><div class="line">  v2 <span class="keyword">as</span> streamV2,</div><div class="line">  v2 <span class="keyword">as</span> streamLatestVersion</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的import命令也是如此。</p>
<h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><p>使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块（文件）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.js</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> &#123;firstName, lastName, year&#125; <span class="keyword">from</span> <span class="string">'./profile'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">element</span>) </span>&#123;</div><div class="line">  element.textContent = firstName + <span class="string">' '</span> + lastName;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; lastName <span class="keyword">as</span> surname &#125; <span class="keyword">from</span> <span class="string">'./profile'</span>;</div></pre></td></tr></table></figure>
<p>import语句会执行所加载的模块，因此可以有下面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">'lodash'</span>;</div></pre></td></tr></table></figure>
<h2 id="模块的整体加载"><a href="#模块的整体加载" class="headerlink" title="模块的整体加载"></a>模块的整体加载</h2><p>除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.js</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="built_in">circle</span> from './<span class="built_in">circle</span>';</div><div class="line"></div><div class="line">console.<span class="built_in">log</span>(<span class="string">'圆面积：'</span> + area(<span class="number">4</span>));</div><div class="line">console.<span class="built_in">log</span>(<span class="string">'圆周长：'</span> + circumference(<span class="number">14</span>));</div></pre></td></tr></table></figure>
<h2 id="export-default命令"><a href="#export-default命令" class="headerlink" title="export default命令"></a>export default命令</h2><p>从前面的例子可以看出，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。</p>
<p>为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// export-default.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">'./export-default'</span>;</div><div class="line">customName(); <span class="comment">// 'foo'</span></div></pre></td></tr></table></figure>
            
                

            
        </div>
    </div>
    <div class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">TAGGED IN</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/ES6/" rel="tag">ES6</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/javascript/" rel="tag">javascript</a>

            </div>
        
        <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2016/03/14/%E8%AF%A5%E7%94%A8async%E5%86%99%E5%BC%82%E6%AD%A5%E4%BB%A3%E7%A0%81%E4%BA%86/"  data-tooltip="该用async写异步代码了">
                
                    <i class="fa fa-angle-left"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                </a>
            </li>
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2016/02/06/2015%20%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%E4%B8%8E%E5%B1%95%E6%9C%9B/" data-tooltip="2015 年终总结与展望">
                
                    <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                    <i class="fa fa-angle-right"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions"  href="#btn-open-shareoptions">
                <i class="fa fa-share-alt"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=http://www.404forest.com/2016/03/13/ES6%E9%87%8D%E7%82%B9%E6%A6%82%E8%A7%88/">
                <i class="fa fa-google-plus"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://www.404forest.com/2016/03/13/ES6%E9%87%8D%E7%82%B9%E6%A6%82%E8%A7%88/">
                <i class="fa fa-facebook-official"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://www.404forest.com/2016/03/13/ES6%E9%87%8D%E7%82%B9%E6%A6%82%E8%A7%88/">
                <i class="fa fa-twitter"></i>
            </a>
        </li>
        
            <li class="post-action">
                <a class="post-action-btn btn btn--default" href="#disqus_thread">
                    <i class="fa fa-comment-o"></i>
                </a>
            </li>
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#">
            
                <i class="fa fa-list"></i>
            </a>
        </li>
    </ul>
</div>


        
            <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Jin. All Rights Reserved.
    </span>
    <a class="copyrights" target="_blank" rel="noopener" href="http://www.beian.miit.gov.cn/">
        浙ICP备18012561号
    </a>
</footer>

            </div>
        </div>
        <div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/ava.png"/>
        
            <h4 id="about-card-name">Jin</h4>
        
            <h5 id="about-card-bio">Interested in Web Development/Typography/Japanese.</h5>
        
        
            <h5 id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                WebDeveloper
            </h5>
        
        
            <h5 id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                Beijing
            </h5>
        
    </div>
</div>

        <div id="cover" style="background-image:url('/assets/images/bg4.jpg');"></div>
    </body>
    <!--SCRIPTS-->

<script src="/assets/js/script.min.js"></script>

<!--SCRIPTS END-->

    <script type="text/javascript">
        var disqus_shortname = '404forest';
        (function() {
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>


    <script type="text/javascript">
        (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
                (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
            e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
        })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

        _st('install','ZkJM8hxyxxLens-VGG__','2.0.0');
    </script>


</html>
