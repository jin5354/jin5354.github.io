
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="404Forest">
    <title>现代前端科技解析 —— 数据响应式系统 (Data Reactivity System) - 404Forest</title>
    <meta name="author" content="Jin">
    
        <link rel="icon" href="/assets/images/favicon.ico">
    
    
    <meta name="description" content="现代前端框架都引入了数据的响应式系统：模型层（Model）只是普通的 JavaScript 对象，修改它则自动更新视图（View），这让状态管理简单而直观。 Vue、Meteor Tracker、Mobx 中的数据响应式系统原理基本相同，本文将对其进行解析，并从零开始一步步实现一个与框架解耦的数据响应式系统。">
<meta property="og:type" content="blog">
<meta property="og:title" content="现代前端科技解析 —— 数据响应式系统 (Data Reactivity System)">
<meta property="og:url" content="http://www.404forest.com/2017/06/28/modern-web-development-tech-analysis-data-reactivity-system/index.html">
<meta property="og:site_name" content="404Forest">
<meta property="og:description" content="现代前端框架都引入了数据的响应式系统：模型层（Model）只是普通的 JavaScript 对象，修改它则自动更新视图（View），这让状态管理简单而直观。 Vue、Meteor Tracker、Mobx 中的数据响应式系统原理基本相同，本文将对其进行解析，并从零开始一步步实现一个与框架解耦的数据响应式系统。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.404forest.com/imgs/blog/reactivity-system-1.png">
<meta property="og:image" content="http://www.404forest.com/imgs/blog/reactivity-system-2.png">
<meta property="og:image" content="http://www.404forest.com/imgs/blog/reactivity-system-3.png">
<meta property="og:image" content="https://cn.vuejs.org/images/data.png">
<meta property="og:image" content="http://www.404forest.com/imgs/blog/reactivity-system-4.png">
<meta property="article:published_time" content="2017-06-28T20:29:11.000Z">
<meta property="article:modified_time" content="2025-02-04T23:02:44.257Z">
<meta property="article:author" content="Jin">
<meta property="article:tag" content="Modern web development tech analysis">
<meta property="article:tag" content="现代前端科技解析">
<meta property="article:tag" content="data reactivity system">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.404forest.com/imgs/blog/reactivity-system-1.png">
<meta name="twitter:creator" content="@jin5354">
    
    
    
        <meta property="og:image" content="/assets/images/ava.png"/>
    
    
    
        <meta property="og:image" content="/2017/06/28/modern-web-development-tech-analysis-data-reactivity-system/traceon.png"/>
        <meta class="swiftype" name="image" data-type="enum" content="http://www.404forest.com/2017/06/28/modern-web-development-tech-analysis-data-reactivity-system/traceon.png" />
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style.min.css">

    <!--STYLES END-->
    
    <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-66492678-1']);
        _gaq.push(['_trackPageview']);
        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
    </script>

</head>

    <body>
        <div id="blog">
            <header id="header" data-behavior="3">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <h1 class="header-title">
        <a class="header-title-link" href="/%20">404Forest</a>
    </h1>
    
        <a class="header-right-picture" href="/#about">
            <img class="header-picture" src="/assets/images/ava.png"/>
        </a>
    
</header>
            <nav id="sidebar" data-behavior="3">
    
        <div class="sidebar-profile">
            <a href="/#about">
                
                    <img class="sidebar-profile-picture" src="/assets/images/ava.png"/>
                
            </a>
            <span class="sidebar-profile-name">Jin</span>
        </div>
    
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/%20"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                    <span class="sidebar-button-desc">Home</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-archives"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                    <span class="sidebar-button-desc">Archive</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-categories"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
                    <span class="sidebar-button-desc">Categories</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-tags"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                    <span class="sidebar-button-desc">Tags</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link st-search-show-outputs"
                         href="#search"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-search"></i>
                    <span class="sidebar-button-desc">Search</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="#about"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-question"></i>
                    <span class="sidebar-button-desc">About</span>
                </a>
        </li>
        
    </ul>
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://github.com/jin5354" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-github"></i>
                    <span class="sidebar-button-desc">GitHub</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="mailto:xiaoyanjinx@gmail.com" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-envelope-o"></i>
                    <span class="sidebar-button-desc">Mail</span>
                </a>
        </li>
        
    </ul>
    
    <div style="margin-left: 27px;">
        <a target="_blank" rel="noopener" href="https://github.com/jin5354/404forest"><img src="https://img.shields.io/github/stars/jin5354/404forest.svg?style=social&label=Stars"></a>
    </div>
</nav>

            
        <div class="post-header-cover
                    text-left
                    post-header-cover--partial"
             style="background-image:url('/2017/06/28/modern-web-development-tech-analysis-data-reactivity-system/traceon.png');"
             data-behavior="3">
            
        </div>

            <div id="main" data-behavior="3"
                 class="hasCover
                        hasCoverMetaOut
                        ">
                <article class="post" itemscope itemType="http://schema.org/BlogPosting">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title" itemprop="headline">
            现代前端科技解析 —— 数据响应式系统 (Data Reactivity System)
        </h1>
    
    <div class="post-meta">
    <time itemprop="datePublished" content="Wed Jun 28 2017 13:29:11 GMT-0700">
	
		    6月 28, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Code/">Code</a>


    
</div>
</div>
    
    <div class="main-content-wrap" style="margin-top: 60px;">索引</div>
    <ol class="main-content-wrap toc-article"><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-1"><a class="main-content-wrap toc-article-link" href="#1-%E4%BD%95%E4%B8%BA%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="main-content-wrap toc-article-text">1. 何为数据响应式系统</span></a><ol class="main-content-wrap toc-article-child"><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#1-1-%E6%8A%9B%E7%A0%96%E5%BC%95%E7%8E%89"><span class="main-content-wrap toc-article-text">1.1 抛砖引玉</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#1-2-ES6-%E5%89%8D%EF%BC%8C%E6%95%B0%E6%8D%AE%E8%BF%BD%E8%B8%AA%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%EF%BC%9AObject-defineProperty"><span class="main-content-wrap toc-article-text">1.2 ES6 前，数据追踪的基础设施：Object.defineProperty</span></a></li></ol></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-1"><a class="main-content-wrap toc-article-link" href="#2-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%93%8D%E5%BA%94%E5%8C%96"><span class="main-content-wrap toc-article-text">2. 数据的响应化</span></a><ol class="main-content-wrap toc-article-child"><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#2-1-%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E6%95%B4%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="main-content-wrap toc-article-text">2.1 递归遍历整个对象</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#2-2-%E6%95%B0%E7%BB%84%E7%9A%84%E7%89%B9%E6%AE%8A%E5%93%8D%E5%BA%94%E5%8C%96%E5%A4%84%E7%90%86"><span class="main-content-wrap toc-article-text">2.2 数组的特殊响应化处理</span></a></li></ol></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-1"><a class="main-content-wrap toc-article-link" href="#3-%E7%B2%BE%E5%87%86%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86"><span class="main-content-wrap toc-article-text">3. 精准依赖收集</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-1"><a class="main-content-wrap toc-article-link" href="#4-%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E9%98%9F%E5%88%97"><span class="main-content-wrap toc-article-text">4. 异步更新队列</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-1"><a class="main-content-wrap toc-article-link" href="#5-%E7%BC%BA%E9%99%B7%E4%B8%8E%E8%A1%A5%E5%85%85"><span class="main-content-wrap toc-article-text">5. 缺陷与补充</span></a><ol class="main-content-wrap toc-article-child"><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#5-1-key-%E7%9A%84%E6%B7%BB%E5%8A%A0%E4%B8%8E%E5%88%A0%E9%99%A4"><span class="main-content-wrap toc-article-text">5.1 key 的添加与删除</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-2"><a class="main-content-wrap toc-article-link" href="#5-2-%E6%B7%B1%E5%BA%A6%E6%95%B0%E6%8D%AE%E8%BF%BD%E8%B8%AA"><span class="main-content-wrap toc-article-text">5.2 深度数据追踪</span></a></li></ol></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-1"><a class="main-content-wrap toc-article-link" href="#6-Proxy%EF%BC%9A%E8%BF%87%E5%8E%BB%E6%9C%AA%E5%8E%BB%EF%BC%8C%E6%9C%AA%E6%9D%A5%E5%B7%B2%E6%9D%A5"><span class="main-content-wrap toc-article-text">6. Proxy：过去未去，未来已来</span></a></li><li class="main-content-wrap toc-article-item main-content-wrap toc-article-level-1"><a class="main-content-wrap toc-article-link" href="#7-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="main-content-wrap toc-article-text">7. 参考资料</span></a></li></ol>
    <div class="post-content markdown" itemprop="articleBody">
        <div class="main-content-wrap">
            <p>现代前端框架都引入了数据的响应式系统：模型层（Model）只是普通的 JavaScript 对象，修改它则自动更新视图（View），这让状态管理简单而直观。 Vue、Meteor Tracker、Mobx 中的数据响应式系统原理基本相同，本文将对其进行解析，并从零开始一步步实现一个与框架解耦的数据响应式系统。</p>
<a id="more"></a>
<blockquote>
<p>注：<br>原始链接: <a href="https://www.404forest.com/2017/06/28/modern-web-development-tech-analysis-data-reactivity-system/">https://www.404forest.com/2017/06/28/modern-web-development-tech-analysis-data-reactivity-system/</a><br>文章备份: <a href="https://github.com/jin5354/404forest/issues/60" target="_blank" rel="external">https://github.com/jin5354/404forest/issues/60</a><br>本文内容所对应的 Vue2.0 源码: <a href="https://github.com/vuejs/vue/tree/dev/src/core/observer" target="_blank" rel="external">https://github.com/vuejs/vue/tree/dev/src/core/observer</a><br>本文构建的数据监测库（附注释和 100% 测试）：<a href="https://github.com/jin5354/leaf-observable" target="_blank" rel="external">https://github.com/jin5354/leaf-observable</a></p>
</blockquote>
<h1 id="1-何为数据响应式系统"><a href="#1-何为数据响应式系统" class="headerlink" title="1. 何为数据响应式系统"></a>1. 何为数据响应式系统</h1><h2 id="1-1-抛砖引玉"><a href="#1-1-抛砖引玉" class="headerlink" title="1.1 抛砖引玉"></a>1.1 抛砖引玉</h2><p>先看一个 Vue 官网上再熟悉不过的双向绑定示例：</p>
<p><img src="/imgs/blog/reactivity-system-1.png" alt="reactivity-system-1"></p>
<p>这个示例展现了 model – view 数据双向绑定的便利。先思考一下，这两个方向的绑定要如何实现？</p>
<p><code>input</code> 数据 view –&gt; model 绑定，我们可以通过事件响应来做到：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> data = &#123;</div><div class="line">  <span class="attr">message</span>: <span class="string">'Hello!'</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> $input = <span class="built_in">document</span>.querySelector(<span class="string">'input'</span>)</div><div class="line">$input.addEventListener(<span class="string">'change'</span>, (e) =&gt; &#123;  <span class="comment">// addEvent 之后每次 input 数据 change，都会自动执行回调函数</span></div><div class="line">  data = e.target.value</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>凭借浏览器内建的 DOM event，我们得以在 input 数据变化时及时得到通知并改变 model。然而 model –&gt; view 绑定似乎并没有方便的手段，若想保证 model 改变时 view 跟随改变，我们只能在每次执行 model 变化操作的地方，手动执行 render 函数重新渲染 view。</p>
<p>如果能有类似事件响应的方便 API 就好了！就像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> data = &#123;</div><div class="line">  <span class="attr">message</span>: <span class="string">'Hello!'</span></div><div class="line">&#125;</div><div class="line">watch(data, render) <span class="comment">// watch 之后每次 data 改变，都会自动执行回调函数 render</span></div><div class="line">data.message = <span class="string">'New Message!'</span> <span class="comment">//自动触发 render 函数！</span></div></pre></td></tr></table></figure>
<p>如果数据的变动能自动发出通知并得到响应，我们就称其为响应式的数据。接下来我们从实现一个基本的 watch 函数开始，逐步构建一个数据响应式系统。</p>
<h2 id="1-2-ES6-前，数据追踪的基础设施：Object-defineProperty"><a href="#1-2-ES6-前，数据追踪的基础设施：Object-defineProperty" class="headerlink" title="1.2 ES6 前，数据追踪的基础设施：Object.defineProperty"></a>1.2 ES6 前，数据追踪的基础设施：Object.defineProperty</h2><p>JavaScript 中对象的每个属性都拥有一个<strong>属性描述对象</strong>，用来定义该属性的行为。<code>Object.defineProperty</code> 是 ES5.1 规范中提供的方法，用来修改对象属性的属性描述对象，文档可参见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="external">MDN-Object.defineProperty()</a>。通过 <code>Object.defineProperty</code> 函数，我们可以通过定义对象属性的存取器（getter/setter）来劫持数据的读取，实现数据变动时的通知功能。</p>
<p>例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> o = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> value = o[<span class="string">'a'</span>]</div><div class="line"></div><div class="line"><span class="comment">// 设置 o.a 的属性描述对象</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'a'</span>, &#123;</div><div class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</div><div class="line">  get() &#123;           <span class="comment">//设置 o.a 的 getter，每次访问 o.a 时执行</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'a 属性被访问到了！'</span>)</div><div class="line">    <span class="keyword">return</span> value</div><div class="line">  &#125;,</div><div class="line">  set(newValue) &#123;   <span class="comment">//设置 o.a 的 setter，每次修改 o.a 时执行</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'a 属性被修改了，新值为:'</span>, newValue, <span class="string">',旧值为：'</span>, value)</div><div class="line">    value = newValue</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">o.a       <span class="comment">// 输出：a 属性被访问到了！</span></div><div class="line">o.a = <span class="number">2</span>   <span class="comment">// 输出：a 属性被修改了，新值为: 2 ,旧值为： 1</span></div></pre></td></tr></table></figure>
<p>getter/setter 劫持了数据的读写操作，使我们可以在数据读写时得到通知并执行自定义的操作，构成了数据响应式系统的基石。Object.defineProperty 方法不支持 IE9 以下浏览器且无法被 polyfill，这也是 Vue 等框架不支持 IE9 以下浏览器的原因。</p>
<h1 id="2-数据的响应化"><a href="#2-数据的响应化" class="headerlink" title="2. 数据的响应化"></a>2. 数据的响应化</h1><p>Object.defineProperty 方法一次只能定义一个键值的属性描述对象。我们可以很轻松的写出针对一个键值的监测函数：</p>
<p><a href="https://jsfiddle.net/jin5354/6mqtabfL/" target="_blank" rel="external">查看在线示例</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> o = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">watch</span>(<span class="params">obj, key, callback</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> value = obj[key]</div><div class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</div><div class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</div><div class="line">    get() &#123;</div><div class="line">      <span class="keyword">return</span> value</div><div class="line">    &#125;,</div><div class="line">    set(newValue) &#123;</div><div class="line">      <span class="keyword">if</span>(newValue === value) &#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">      &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">let</span> oldValue = value</div><div class="line">        value = newValue</div><div class="line">        callback(newValue, oldValue)  <span class="comment">// setter 中触发回调函数，并将新值与旧值作为参数传入</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//『使数据响应化』和『添加回调函数』两个操作现在是耦合在一起的</span></div><div class="line">watch(o, <span class="string">'a'</span>, (newValue, oldValue) =&gt; &#123;   <span class="comment">// 使 o.a 响应化</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'属性被修改了，新值为:'</span>, newValue, <span class="string">',旧值为：'</span>, oldValue)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">o.a = <span class="number">2</span>   <span class="comment">// 输出： 属性被修改了，新值为: 2 ,旧值为： 1</span></div><div class="line">o.a = <span class="number">3</span>   <span class="comment">// 输出： 属性被修改了，新值为: 3 ,旧值为： 2</span></div></pre></td></tr></table></figure>
<h2 id="2-1-递归遍历整个对象"><a href="#2-1-递归遍历整个对象" class="headerlink" title="2.1 递归遍历整个对象"></a>2.1 递归遍历整个对象</h2><p>为了让整个对象响应化，我们需要遍历对象中的所有键并为其应用 Object.defineProperty 方法。对于键值为对象的情况，递归进去处理。同时，为了让 『使数据响应化』和『添加回调函数』两个操作解耦，我们引入 Dep 和 Watcher 类，使用订阅/发布模式向响应式数据注册回调函数。</p>
<p><img src="/imgs/blog/reactivity-system-2.png" alt="reactivity-system-2"></p>
<p><a href="https://jsfiddle.net/jin5354/aLbg4ja2/" target="_blank" rel="external">查看在线示例</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Dep 类，保存数据源的所有订阅，并在接收到数据源的变动通知后，触发所有订阅</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.subs = []</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  addSub(sub) &#123;  <span class="comment">// 添加订阅</span></div><div class="line">    <span class="keyword">this</span>.subs.push(sub)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  notify(newValue, oldValue) &#123;</div><div class="line">    <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> &#123;</div><div class="line">      sub.update(newValue, oldValue) <span class="comment">// 触发订阅</span></div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> globalDep = <span class="keyword">new</span> Dep()</div><div class="line"></div><div class="line"><span class="comment">// Watcher 类，每个 Watcher 为一个订阅源</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(callback) &#123;</div><div class="line">    <span class="keyword">this</span>.callback = callback</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  update(newValue, oldValue) &#123;</div><div class="line">    <span class="keyword">this</span>.callback(newValue, oldValue)  <span class="comment">// 被触发后执行回调</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 使一个对象响应化</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">observify</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span>(!isObject(value)) &#123;</div><div class="line">    <span class="keyword">return</span></div><div class="line">  &#125;</div><div class="line">  <span class="built_in">Object</span>.keys(value).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</div><div class="line">    defineReactive(value, key, value[key])  <span class="comment">// 遍历每个键使其响应化</span></div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">'object'</span> &amp;&amp; value !== <span class="literal">null</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//为对象的一个键应用 Object.defineProperty</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, value</span>) </span>&#123;</div><div class="line">  observify(value) <span class="comment">// 递归</span></div><div class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</div><div class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</div><div class="line">    get() &#123;</div><div class="line">      <span class="keyword">return</span> value</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">set</span>: <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</div><div class="line">      <span class="keyword">if</span>(newValue === value) &#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">      &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">let</span> oldValue = value</div><div class="line">        value = newValue</div><div class="line">        observify(newValue)</div><div class="line">        globalDep.notify(newValue, oldValue) <span class="comment">// 变动时通知 Dep</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> o = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">c</span>: &#123;</div><div class="line">    <span class="attr">d</span>: <span class="number">1</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//『使数据响应化』和『添加回调函数』两个操作已被解耦，解耦后可以方便的多次添加订阅</span></div><div class="line"><span class="comment">// 使数据响应化</span></div><div class="line">observify(o)</div><div class="line"><span class="comment">// 添加订阅</span></div><div class="line">globalDep.addSub(<span class="keyword">new</span> Watcher(<span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'发生改变！新值：'</span>, newValue, <span class="string">"，旧值："</span>, oldValue)</div><div class="line">&#125;))</div><div class="line"></div><div class="line">o.a = <span class="number">2</span>  <span class="comment">// 输出：发生改变！新值： 2 ，旧值： 1</span></div><div class="line">o.c.d = <span class="number">4</span>  <span class="comment">// 输出：发生改变！新值： 4 ，旧值： 1</span></div><div class="line"></div><div class="line"><span class="comment">// 可以再添加一个订阅</span></div><div class="line">globalDep.addSub(<span class="keyword">new</span> Watcher(<span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'新订阅'</span>)</div><div class="line">&#125;))</div><div class="line"></div><div class="line">o.a = <span class="number">3</span> <span class="comment">// 输出：发生改变！新值： 3 ，旧值： 2</span></div><div class="line">        <span class="comment">// 输出：新订阅</span></div></pre></td></tr></table></figure>
<h2 id="2-2-数组的特殊响应化处理"><a href="#2-2-数组的特殊响应化处理" class="headerlink" title="2.2 数组的特殊响应化处理"></a>2.2 数组的特殊响应化处理</h2><p>我们已经清楚：变动能够通知全是凭借 setter 的能力，在数据被修改时执行自定义操作。然而我们操作数组时往往使用 <code>push</code>、<code>pop</code>、<code>shift</code> 等函数来操作——很遗憾，调用这些函数修改数组内容并不会触发 setter。</p>
<p>为了能监测到这些函数操作带来的变动，我们需要『偷梁换柱』：用自制的变异函数替代这些原生函数。首先使用 <code>Object.create</code> 创建一个原型为 <code>Array.prototype</code> 的对象，拿到 Array 实例方法；然后在该对象上定义同名的变异函数，shadow 掉原生函数；随后将要响应化的数组的原型指向该对象，欺骗数组使用变异函数。</p>
<p><a href="https://jsfiddle.net/jin5354/cz7f99bc/" target="_blank" rel="external">查看在线示例</a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">import _ from 'lodash'</div><div class="line"></div><div class="line">// 数组响应化</div><div class="line">function observifyArray(arr) &#123;</div><div class="line">  const aryMethods = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'] //需要变异的函数名列表</div><div class="line">  let arrayAugmentations = Object.create(Array.prototype) // 创建一个 __proto__ 到 Array.prototype 的 arrayAugmentations 对象</div><div class="line">  aryMethods.forEach(method =&gt; &#123;    // 在 arrayAugmentations 对象上将需要变异的函数重写</div><div class="line">    arrayAugmentations[method] = function(...arg) &#123;</div><div class="line">      Array.prototype[method].apply(this, arg)  // 执行默认操作</div><div class="line">      globalDep.notify()  // 重写后的函数会先执行默认操作，随后通知 Dep</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  Object.setPrototypeOf(arr, arrayAugmentations)  // 将要监测的数组的原型对象设置为 arrayAugmentations 对象，这样执行 push 等方法时就会执行我们替换后的变异方法啦</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 修改上文中的 observify 函数，加入 observifyArray</div><div class="line">function observify(value) &#123;</div><div class="line">  if(!isObject(value)) &#123;</div><div class="line">    return</div><div class="line">  &#125;</div><div class="line">  if(Array.isArray(value)) &#123;  // 由于性能问题，我们不再对数组的每个 key 执行 Object.defineReactive</div><div class="line">    observifyArray(value)</div><div class="line">    for(let i = 0; i &lt; value.length; i++) &#123;</div><div class="line">      observify(value[i])</div><div class="line">    &#125;</div><div class="line">  &#125;else &#123;</div><div class="line">    Object.keys(value).forEach((key) =&gt; &#123;</div><div class="line">      defineReactive(value, key, value[key])  // 遍历每个键使其响应化</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">... 其他部分引用 #2.1 示例</div><div class="line"></div><div class="line">let o = &#123;</div><div class="line">  a: [1, 2, 3]</div><div class="line">&#125;</div><div class="line"></div><div class="line">observify(o)</div><div class="line"></div><div class="line">globalDep.addSub(new Watcher((newValue, oldValue) =&gt; &#123;</div><div class="line">  console.log('发生改变！新值：', newValue, "，旧值：", oldValue)</div><div class="line">&#125;))</div><div class="line"></div><div class="line">o.a.push(4) // 输出：发生改变！新值： (4) [1, 2, 3, 4] ，旧值： (3) [1, 2, 3]</div></pre></td></tr></table></figure>
<h1 id="3-精准依赖收集"><a href="#3-精准依赖收集" class="headerlink" title="3. 精准依赖收集"></a>3. 精准依赖收集</h1><p>回顾一下我们的数据响应式系统，现在我们有 observify 方法使一个对象（还有难伺候的数组！）响应化，有个全局 Dep 类存放多个订阅，还有 Watcher 生成订阅源。将对象响应化之后，我们可以生成订阅，添加订阅，追加订阅。每当对象被修改，Dep 就会收到通知，然后通知所有订阅源都执行回调。</p>
<p>考虑生产环境中一个常见的场景：页面模板中只引用了 <code>o.a</code> 和 <code>o.b</code>，如 <code>&lt;p&gt;{o.a + o.b}&lt;/p&gt;</code>。我们期望数据变化时，自动执行 <code>render</code> 函数重新渲染页面，然而当 <code>o.c</code> 等无关数据发生变化时，也会触发订阅源的更新，这就造成了性能的浪费。如何让我们的监测更智能一些，只在『用到的数据』变化时，才触发订阅源的更新呢？这时 <code>getter</code> 就派上用武之地了。</p>
<p><code>&lt;p&gt;{a + b}&lt;/p&gt;</code> 模板引擎在编译时会被解释为 render 函数。本文不会涉及编译相关内容，我们可以简单的理解为，该段模板最终会编译为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">'&lt;p&gt;'</span> + (o.a + o.b) + <span class="string">'&lt;/p&gt;'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在页面的初始化阶段，render 函数会执行一次，得到初始结果。函数执行时，所依赖的数据一定会被访问，并触发其 getter，未依赖的数据则不会触发 getter。我们可以在 getter 过程中标记当前的键，即『依赖收集』，仅在被标记的键修改时，才去触发订阅的更新。</p>
<p>由于现在的订阅颗粒度由数据整体细化到了单独的键，所以一个全局 Dep 是不够用的。我们需要为每个键都维护一个 Dep。</p>
<p><img src="/imgs/blog/reactivity-system-3.png" alt="reactivity-system-3"></p>
<p>在键的 getter 触发时将当前 watcher 加入 dep 中，完成依赖收集。setter 触发时通知当前键的 dep，执行订阅源的更新。这样即可实现『仅当依赖到的数据修改时，才触发更新』了。</p>
<p>继续完善我们的响应式系统：</p>
<p><a href="https://jsfiddle.net/jin5354/hb59dkyf/" target="_blank" rel="external">在线示例</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Dep 类，添加依赖收集方法 depend</span></div><div class="line"><span class="keyword">let</span> uid = <span class="number">1</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.id = uid++ <span class="comment">// 为每个 dep 标记一个 uid</span></div><div class="line">    <span class="keyword">this</span>.subs = []</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  addSub(sub) &#123;</div><div class="line">    <span class="keyword">this</span>.subs.push(sub)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  depend() &#123; <span class="comment">// 依赖收集函数，在 getter 中执行，在 Dep.target 上找到当前 watcher，并添加依赖</span></div><div class="line">    Dep.target &amp;&amp; Dep.target.addDep(<span class="keyword">this</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  notify() &#123;</div><div class="line">    <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> &#123;</div><div class="line">      sub.update()</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">Dep.target = <span class="literal">null</span> <span class="comment">// Dep.target 用来暂存正在收集依赖的当前 watcher</span></div><div class="line"></div><div class="line"><span class="comment">// 现在 Wactcher 接收三个参数，第一个为依赖收集函数（如上文的 render），第二个为回调，第三个为附加配置</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>(expFn, cb, options = &#123;&#125;) &#123;</div><div class="line">    <span class="keyword">this</span>.context = options.context</div><div class="line">    <span class="keyword">this</span>.expFn = expFn</div><div class="line">    <span class="keyword">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>()  <span class="comment">//标记当前 watcher 已经加入到了哪些 dep</span></div><div class="line">    <span class="keyword">this</span>.cb = cb</div><div class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.subAndGetValue()</div><div class="line">    <span class="keyword">this</span>.clonedOldValue = _.cloneDeep(<span class="keyword">this</span>.value)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 执行回调</span></div><div class="line">  update() &#123;</div><div class="line">    <span class="keyword">let</span> value = <span class="keyword">this</span>.subAndGetValue() <span class="comment">//获取 newValue</span></div><div class="line">    <span class="keyword">if</span>(!_.isEqual(value, <span class="keyword">this</span>.clonedOldValue)) &#123; <span class="comment">// 比对前后两次值是否相等时借助一下 lodash 中的 isEqual 函数进行比较</span></div><div class="line">      <span class="keyword">this</span>.value = value</div><div class="line">      <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.context, value, <span class="keyword">this</span>.clonedOldValue)</div><div class="line">      <span class="keyword">this</span>.clonedOldValue = _.cloneDeep(value) <span class="comment">// 缓存本次结果，会成为下次的 oldValue, 对于对象使用深拷贝</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//执行依赖收集函数，订阅依赖！</span></div><div class="line">  subAndGetValue() &#123;</div><div class="line">    Dep.target = <span class="keyword">this</span> <span class="comment">// 把当前 watcher 放到 Dep.target 上，这样 getter 就知道应该把哪个 watcher 加入 dep 中了。</span></div><div class="line">    <span class="keyword">let</span> value = <span class="keyword">this</span>.expFn.call(<span class="keyword">this</span>.context)</div><div class="line">    Dep.target = <span class="literal">null</span> <span class="comment">// 订阅完置回空。</span></div><div class="line">    <span class="keyword">return</span> value</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 在 dep 上添加订阅</span></div><div class="line">  addDep(dep) &#123;</div><div class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.depIds.has(dep.id)) &#123; <span class="comment">//防止重复订阅，防止在一个 dep 中订阅两次</span></div><div class="line">      <span class="keyword">this</span>.depIds.add(dep.id)</div><div class="line">      dep.addSub(<span class="keyword">this</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//简单封装下 new Watcher</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">watch</span>(<span class="params">expFn, cb, context</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Watcher(expFn, cb, context)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 修改 defineReactive</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, value</span>) </span>&#123;</div><div class="line">  <span class="comment">//为每个键都创建一个 dep</span></div><div class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</div><div class="line"></div><div class="line">  observify(value)</div><div class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</div><div class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</div><div class="line">    get() &#123;</div><div class="line">      <span class="keyword">if</span>(Dep.target) &#123;</div><div class="line">        dep.depend()</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> value</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">set</span>: <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</div><div class="line">      <span class="keyword">if</span>(newValue === value) &#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">      &#125;<span class="keyword">else</span> &#123;</div><div class="line">        value = newValue</div><div class="line">        observify(newValue)</div><div class="line">        dep.notify()</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">... 其他部分不变</div><div class="line"></div><div class="line"><span class="keyword">let</span> o = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">b</span>: <span class="number">2</span>,</div><div class="line">  <span class="attr">c</span>: &#123;</div><div class="line">    <span class="attr">d</span>: <span class="number">3</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">observify(o)</div><div class="line"></div><div class="line">watch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> o.a + o.b</div><div class="line">&#125;, (newValue, oldValue) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'更新！新值为：'</span>, newValue, <span class="string">'，旧值为：'</span>, oldValue)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">o.b = <span class="number">3</span>  <span class="comment">//  输出：更新！新值为： 4 ，旧值为： 3</span></div><div class="line">o.c.d = <span class="number">4</span>  <span class="comment">// 无输出</span></div></pre></td></tr></table></figure>
<p>由于不存在全局 dep，且向 dep 中注册订阅的操作在 getter 中依赖收集阶段自动执行了，所以我们不再需要手动操作 dep。现在我们的数据响应式系统只需要暴露两个 api：<code>observify</code> 和 <code>watch</code> 就够了。<code>watch</code> 中接收两个函数，第一个 expFn 函数根据依赖返回需要的结果；第二个函数则是第一个函数结果的回调。</p>
<p>我们的响应式系统已经可以实现 Vue 中的 watch 和 computed 功能：watch 某个键值的变动，如 o.a ，实际就是 expFn 函数返回该键的值；而计算属性就是将计算属性的函数体作为 expFn，回调中赋值即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 实现 Vue 中的 watch 某个键的功能</span></div><div class="line">watch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> o.a</div><div class="line">&#125;, (newValue, oldValue) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'更新！新值为：'</span>, newValue, <span class="string">'，旧值为：'</span>, oldValue)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 实现 Vue 中的计算属性，比如新增一个叫 something 的计算属性</span></div><div class="line">watch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> o.a + o.b</div><div class="line">&#125;, (newValue, oldValue) =&gt; &#123;</div><div class="line">  something = newValue</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//实现 Vue 中的自动更新，每次依赖数据变化时重新渲染 DOM</span></div><div class="line">watch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">'&lt;p&gt;'</span> + (o.a + o.b) + <span class="string">'&lt;/p&gt;'</span></div><div class="line">&#125;, (newValue) =&gt; &#123;</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>).innerHTML = newValue</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>现在我们来看 Vue 文档中响应式系统的示意图，就非常好理解了。</p>
<p><img src="https://cn.vuejs.org/images/data.png" alt="vue-reactivity"></p>
<h1 id="4-异步更新队列"><a href="#4-异步更新队列" class="headerlink" title="4. 异步更新队列"></a>4. 异步更新队列</h1><p>考虑这种情况：我们拥有形如 <code>&lt;p&gt;{o.a + o.b + o.c.d}&lt;/p&gt;</code> 的模板，它会被编译为拥有 3 个依赖的 render 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> o = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">b</span>: <span class="number">2</span>,</div><div class="line">  <span class="attr">c</span>: &#123;</div><div class="line">    <span class="attr">d</span>: <span class="number">3</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">observify(o)</div><div class="line"></div><div class="line">watch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> o.a + o.b + o.c.d</div><div class="line">&#125;, (newValue, oldValue) =&gt; &#123;</div><div class="line">  ...更新 DOM 的操作...</div><div class="line">  console.log(<span class="string">'更新DOM！新值为：'</span>, newValue, <span class="string">'，旧值为：'</span>, oldValue)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">o.a = <span class="number">2</span>  <span class="comment">//  更新DOM！新值为： 7 ，旧值为： 6</span></div><div class="line">o.a = <span class="number">3</span>  <span class="comment">//  更新DOM！新值为： 8 ，旧值为： 7</span></div><div class="line">o.a = <span class="number">4</span>  <span class="comment">//  更新DOM！新值为： 9 ，旧值为： 8</span></div></pre></td></tr></table></figure>
<p>这段代码执行了三次 render 函数。实际上我们只需要执行最后一次的 render 即可得到结果，前两次的 render 可以丢弃。我们可以开启一个<strong>队列</strong>，将一个<strong>事件循环</strong>内的全部数据变动缓冲在其中，并对 watcher 做去重操作。在下一个 tick 中我们再将队列中的 watcher 依次取出并执行更新。这对避免不必要的计算和 DOM 操作非常重要。</p>
<p>继续改进我们的系统：默认情况下数据变动会缓冲，推入队列；同时为 watcher 函数的配置项中增加 <code>immediate</code> 字段，显式标记为 <code>true</code> 的 watcher 不进行缓冲，依然会在数据变动后立刻执行回调，保持灵活性。</p>
<p><a href="https://jsfiddle.net/jin5354/atq6Lc4x/" target="_blank" rel="external">在线示例</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 利用 MutationObserver 或 Promise.then(环境不支持MO时) 实现简易的 nextTick 函数</span></div><div class="line"><span class="comment">// MutationObserver 与 Promise.then 中的回调均在下一个 microTask 中执行</span></div><div class="line"><span class="comment">// from https://github.com/nx-js/observer-util/blob/master/src/nextTick.js</span></div><div class="line"><span class="keyword">const</span> supportMO = <span class="keyword">typeof</span> MutationObserver !== <span class="string">'undefined'</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">nextTick</span>(<span class="params">task</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</div><div class="line">    <span class="comment">/* istanbul ignore if */</span></div><div class="line">    <span class="keyword">if</span>(supportMO) &#123;</div><div class="line">      <span class="keyword">let</span> counter = <span class="number">1</span></div><div class="line">      <span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(task)</div><div class="line">      <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter))</div><div class="line">      observer.observe(textNode, &#123;<span class="attr">characterData</span>: <span class="literal">true</span>&#125;)</div><div class="line">      textNode.textContent = <span class="number">2</span></div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve().then(task)</div><div class="line">    &#125;</div><div class="line">  &#125;)()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 维护队列，只有 watcher id 不同时才推入，避免重复计算</span></div><div class="line"><span class="keyword">const</span> queue = []</div><div class="line"><span class="keyword">let</span> watcherIds = &#123;&#125;</div><div class="line"><span class="keyword">let</span> waiting = <span class="literal">false</span></div><div class="line"></div><div class="line"><span class="comment">// 执行队列中全部的 watcher</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushSchedulerQueue</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  queue.forEach(<span class="function"><span class="params">watcher</span> =&gt;</span> &#123;</div><div class="line">    watcher.run()</div><div class="line">  &#125;)</div><div class="line">  <span class="comment">// 执行完 watcher 后重置 queue 状态</span></div><div class="line">  queue.length = <span class="number">0</span></div><div class="line">  watcherIds = &#123;&#125;</div><div class="line">  waiting = <span class="literal">false</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 将 watcher 推入 queue</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">queueWatcher</span>(<span class="params">watcher</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> uid = watcher.uid</div><div class="line"></div><div class="line">  <span class="comment">//去重</span></div><div class="line">  <span class="keyword">if</span>(!watcherIds[uid]) &#123;</div><div class="line">    watcherIds[uid] = <span class="literal">true</span></div><div class="line">    queue.push(watcher)</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!waiting) &#123;</div><div class="line">      waiting = <span class="literal">true</span></div><div class="line">      nextTick(flushSchedulerQueue) <span class="comment">// 在下个 tick 时执行 flushSchedulerQueue</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// watcher 中加入 id 标识身份，加入 immediate 字段，true 时才执行回调，否则推入队列</span></div><div class="line"><span class="keyword">let</span> watcherUid = <span class="number">1</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>(expFn, cb, options = &#123;&#125;) &#123;</div><div class="line">    <span class="keyword">this</span>.uid = watcherUid++</div><div class="line">    <span class="keyword">this</span>.context = options.context</div><div class="line">    <span class="keyword">this</span>.immediate = options.immediate</div><div class="line">    <span class="keyword">this</span>.expFn = expFn</div><div class="line">    <span class="keyword">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>()  <span class="comment">//标记当前 watcher 已经加入到了哪些 dep</span></div><div class="line">    <span class="keyword">this</span>.cb = cb</div><div class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.subAndGetValue()</div><div class="line">    <span class="keyword">this</span>.clonedOldValue = _.cloneDeep(<span class="keyword">this</span>.value)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * [update 更新，根据 immediate 参数判断是否立刻执行回调]</div><div class="line">   */</div><div class="line">  update() &#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.immediate) &#123;</div><div class="line">      <span class="keyword">this</span>.run()</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">      queueWatcher(<span class="keyword">this</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * [run 执行回调]</div><div class="line">   */</div><div class="line">  run() &#123;</div><div class="line">    <span class="keyword">let</span> value = <span class="keyword">this</span>.subAndGetValue() <span class="comment">//获取 newValue</span></div><div class="line">    <span class="keyword">if</span>(!_.isEqual(value, <span class="keyword">this</span>.clonedOldValue)) &#123;</div><div class="line">      <span class="keyword">this</span>.value = value</div><div class="line">      <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.context, value, <span class="keyword">this</span>.clonedOldValue)</div><div class="line">      <span class="keyword">this</span>.clonedOldValue = _.cloneDeep(value) <span class="comment">// 缓存本次结果，会成为下次的 oldValue</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">...其他部分相同</div><div class="line"></div><div class="line"><span class="keyword">let</span> o = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">b</span>: <span class="number">2</span>,</div><div class="line">  <span class="attr">c</span>: &#123;</div><div class="line">    <span class="attr">d</span>: <span class="number">3</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">observify(o)</div><div class="line"></div><div class="line">watch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> o.a + o.b</div><div class="line">&#125;, (newValue, oldValue) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'更新！新值为：'</span>, newValue, <span class="string">'，旧值为：'</span>, oldValue)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">watch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> o.b + o.c.d</div><div class="line">&#125;, (newValue, oldValue) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'更新！新值为：'</span>, newValue, <span class="string">'，旧值为：'</span>, oldValue)</div><div class="line">&#125;, &#123;</div><div class="line">  <span class="attr">immediate</span>: <span class="literal">true</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line">o.b = <span class="number">3</span> <span class="comment">// 输出：更新！新值为： 6 ，旧值为： 5</span></div><div class="line">o.b = <span class="number">4</span> <span class="comment">// 输出：更新！新值为： 7 ，旧值为： 6</span></div><div class="line"></div><div class="line">o.a = <span class="number">2</span></div><div class="line">o.a = <span class="number">3</span></div><div class="line">o.a = <span class="number">4</span> <span class="comment">// 只输出一次： 更新！新值为： 8 ，旧值为： 3</span></div></pre></td></tr></table></figure>
<h1 id="5-缺陷与补充"><a href="#5-缺陷与补充" class="headerlink" title="5. 缺陷与补充"></a>5. 缺陷与补充</h1><h2 id="5-1-key-的添加与删除"><a href="#5-1-key-的添加与删除" class="headerlink" title="5.1 key 的添加与删除"></a>5.1 key 的添加与删除</h2><p>由于 watcher 在 getter 注册的 dep 只能被 setter 操作所触发更新，所以不触发 setter 操作的修改行为就无法触发订阅更新，比如对象键值的添加与删除，以及数组的变异方法（上文中的变异方法通知的是全局 Dep，使用依赖收集后的 get/set Dep 无法被变异方法访问到）。</p>
<p>由于只有对象和数组存在这些问题，所以 Vue 除了每个 key 的 dep 外，还为每个 key 对应值为对象/数组创建了另一个 dep，挂在该对象和数组的 __ob__ 属性上。在依赖收集阶段，watcher 将被同时注册在这两个 dep 上，准备接收响应。setter 操作，通知 set/get 中的 dep；非 setter 操作，如对象 key 添加删除、数组变异方法调用，通知 __ob__ 中的 dep。</p>
<p>添加函数 <code>set</code> 与删除函数 <code>del</code> 的代码不再赘述，详见 <a href="https://github.com/jin5354/leaf-observable" target="_blank" rel="external">leaf-observable</a> 内 <code>observable.js</code> 的<a href="https://github.com/jin5354/leaf-observable/blob/master/src/observable.js#L136-L189" target="_blank" rel="external">相关代码</a>。</p>
<p><img src="/imgs/blog/reactivity-system-4.png" alt="reactivity-system-4"></p>
<h2 id="5-2-深度数据追踪"><a href="#5-2-深度数据追踪" class="headerlink" title="5.2 深度数据追踪"></a>5.2 深度数据追踪</h2><p>考虑：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">let o = &#123;</div><div class="line">  <span class="selector-tag">a</span>: &#123; <span class="selector-tag">b</span>: &#123; c: &#123; d: &#123; e: <span class="number">1</span> &#125;&#125;&#125;&#125;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="title">observify</span><span class="params">(o)</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="title">watch</span><span class="params">(()</span></span> =&gt; &#123;</div><div class="line">  return o<span class="selector-class">.a</span><span class="selector-class">.b</span><span class="selector-class">.c</span></div><div class="line">&#125;, (newValue, oldValue) =&gt; &#123;</div><div class="line">  console.log(<span class="string">'更新！新值为：'</span>, newValue, <span class="string">'，旧值为：'</span>, oldValue)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">o<span class="selector-class">.a</span><span class="selector-class">.b</span> = &#123; <span class="comment">// 输出：更新！新值为： Object ，旧值为： Object</span></div><div class="line">  c: &#123;</div><div class="line">    d: &#123;</div><div class="line">      e: <span class="number">2</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">o<span class="selector-class">.a</span><span class="selector-class">.b</span><span class="selector-class">.c</span><span class="selector-class">.d</span><span class="selector-class">.e</span> = <span class="number">3</span> <span class="comment">//无输出</span></div></pre></td></tr></table></figure>
<p>依赖收集过程中访问 o.a.b.c 时，依次触发了 o.a、o.a.b、o.a.b.c 的 getter，将 watcher 注册进对应的 dep，所以 o.a.b.c 的上游变化同样可以监测到；但是修改 c 内部的属性时便无法得到通知。（对于复杂类型值的 setter，只监测引用变化，不监测内部变化）</p>
<p>我们可以增加一个 deep watch 功能。原理很简单：当发现依赖目标为一个对象时，递归进去遍历每一个子属性，主动触发一下 getter 即可。</p>
<p>具体代码不再赘述，可参见 <a href="https://github.com/jin5354/leaf-observable" target="_blank" rel="external">leaf-observable</a> 内 <code>watcher.js</code> 中 <code>deep watch</code> 的<a href="https://github.com/jin5354/leaf-observable/blob/master/src/watcher.js#L61-L72" target="_blank" rel="external">相关代码</a>。</p>
<h1 id="6-Proxy：过去未去，未来已来"><a href="#6-Proxy：过去未去，未来已来" class="headerlink" title="6. Proxy：过去未去，未来已来"></a>6. Proxy：过去未去，未来已来</h1><blockquote>
<p>ES6 为 JavaScript 增加了几种新的元编程形式，其中最明显的特性即为代理（Proxy）。一个 Proxy 是一种特殊对象，包在另一个普通对象前面，你可以在代理对象上注册特殊的处理器，当对这个代理实施各种操作时被调用。这些处理器除了将操作<strong>传送</strong>到原本的目标/被包装的对象上之外，还有机会运行额外的逻辑。</p>
</blockquote>
<p>代理能够观察到的处理器（一部分）：</p>
<table>
<thead>
<tr>
<th>处理器</th>
<th>触发时机</th>
</tr>
</thead>
<tbody>
<tr>
<td>get(..)</td>
<td>在代理上访问一个属性（Reflect.get(..)，.属性操作符或[ .. ]属性操作符）</td>
</tr>
<tr>
<td>set(..)</td>
<td>在代理对象上设置一个属性（Reflect.set(..)，=赋值操作符，或者解构赋值 —— 如果目标是一个对象属性的话)</td>
</tr>
<tr>
<td>deleteProperty(..)</td>
<td>在代理对象上删除一个属性 (Reflect.deleteProperty(..)或delete)</td>
</tr>
<tr>
<td>apply(..)</td>
<td>代理作为一个普通函数/方法被调用（Reflect.apply(..)，call(..)，apply(..)，或者(..)调用操作符）</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>Proxy 不但可以取代 <code>Object.defineProperty</code> 并且还扩增了非常多的功能。Proxy 技术支持监测数组的 push 等方法操作，支持对象属性的动态添加和删除，极大的简化了响应化的代码量。</p>
<p>当前 Proxy 的不足也很明显：不支持 Polyfill，浏览器兼容性非常差（IE 全系列不支持，iOS 10+ 支持，Android 5+ 支持），且因为是『代理』而非劫持，不能直接操作原对象，只能操作代理对象。但是相信，随着浏览器支持逐步跟上，强大的 Proxy 一定会成为下一代数据监测的首选方案。</p>
<p>几个由 Proxy 驱动的数据监测库，推荐阅读源码：</p>
<ul>
<li><a href="https://github.com/ascoders/dynamic-object" target="_blank" rel="external">dynamic-object</a></li>
<li><a href="https://github.com/nx-js/observer-util/" target="_blank" rel="external">observer-util</a></li>
</ul>
<h1 id="7-参考资料"><a href="#7-参考资料" class="headerlink" title="7. 参考资料"></a>7. 参考资料</h1><ol>
<li><a href="http://javascript.ruanyifeng.com/stdlib/attributes.html#toc2" target="_blank" rel="external">JavaScript 标准参考教程 - Object.defineProperty()</a></li>
<li><a href="https://segmentfault.com/a/1190000004384515" target="_blank" rel="external">vue 源码分析之如何实现 observer 和 watcher</a></li>
<li><a href="https://github.com/youngwind/blog/labels/Vue" target="_blank" rel="external">vue早期源码学习系列</a></li>
<li><a href="https://github.com/Ma63d/vue-analysis/issues/1" target="_blank" rel="external">Vue源码详细解析(一)–数据的响应化 </a></li>
<li><a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="external">深入响应式原理</a></li>
<li><a href="https://github.com/DMQ/mvvm" target="_blank" rel="external">剖析Vue实现原理 - 如何实现双向绑定mvvm</a></li>
<li><a href="https://github.com/Ma63d/vue-analysis" target="_blank" rel="external">Vue源码注释版</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/25585910" target="_blank" rel="external">Mobx 思想的实现原理，及与 Redux 对比</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/27097547" target="_blank" rel="external">从零开始用 proxy 实现 Mobx</a></li>
<li><a href="http://www.zcfy.cc/article/writing-a-javascript-framework-data-binding-with-es6-proxies-risingstack-1655.html" target="_blank" rel="external">使用 ES6 Proxy 实现数据绑定</a></li>
<li><a href="http://caniuse.com/#search=proxy" target="_blank" rel="external">Can I use Proxy?</a></li>
<li><a href="https://github.com/jin5354/leaf-observable" target="_blank" rel="external">leaf-observable</a></li>
</ol>

            
                

            
        </div>
    </div>
    <div class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">TAGGED IN</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/Modern-web-development-tech-analysis/" rel="tag">Modern web development tech analysis</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/data-reactivity-system/" rel="tag">data reactivity system</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/%E7%8E%B0%E4%BB%A3%E5%89%8D%E7%AB%AF%E7%A7%91%E6%8A%80%E8%A7%A3%E6%9E%90/" rel="tag">现代前端科技解析</a>

            </div>
        
        <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2017/07/18/how-javascript-actually-works-eventloop-and-uirendering/"  data-tooltip="深入探究 eventloop 与浏览器渲染的时序问题">
                
                    <i class="fa fa-angle-left"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                </a>
            </li>
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2017/06/12/optimie-webpack-bundle-performance/" data-tooltip="Webpack 构建性能优化实践">
                
                    <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                    <i class="fa fa-angle-right"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions"  href="#btn-open-shareoptions">
                <i class="fa fa-share-alt"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=http://www.404forest.com/2017/06/28/modern-web-development-tech-analysis-data-reactivity-system/">
                <i class="fa fa-google-plus"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://www.404forest.com/2017/06/28/modern-web-development-tech-analysis-data-reactivity-system/">
                <i class="fa fa-facebook-official"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://www.404forest.com/2017/06/28/modern-web-development-tech-analysis-data-reactivity-system/">
                <i class="fa fa-twitter"></i>
            </a>
        </li>
        
            <li class="post-action">
                <a class="post-action-btn btn btn--default" href="#disqus_thread">
                    <i class="fa fa-comment-o"></i>
                </a>
            </li>
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#">
            
                <i class="fa fa-list"></i>
            </a>
        </li>
    </ul>
</div>


        
            <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Jin. All Rights Reserved.
    </span>
    <a class="copyrights" target="_blank" rel="noopener" href="http://www.beian.miit.gov.cn/">
        浙ICP备18012561号
    </a>
</footer>

            </div>
        </div>
        <div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/ava.png"/>
        
            <h4 id="about-card-name">Jin</h4>
        
            <h5 id="about-card-bio">Interested in Web Development/Typography/Japanese.</h5>
        
        
            <h5 id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                WebDeveloper
            </h5>
        
        
            <h5 id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                Beijing
            </h5>
        
    </div>
</div>

        <div id="cover" style="background-image:url('/assets/images/bg4.jpg');"></div>
    </body>
    <!--SCRIPTS-->

<script src="/assets/js/script.min.js"></script>

<!--SCRIPTS END-->

    <script type="text/javascript">
        var disqus_shortname = '404forest';
        (function() {
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>


    <script type="text/javascript">
        (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
                (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
            e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
        })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

        _st('install','ZkJM8hxyxxLens-VGG__','2.0.0');
    </script>


</html>
